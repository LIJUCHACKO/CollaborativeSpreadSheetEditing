package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"sync"
	"time"

	"strings"

	"python-libs/data"

	"github.com/kluctl/go-embed-python/embed_util"
	"github.com/kluctl/go-embed-python/python"
)

const dataDir = "../DATA"

func firstNChar(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "..."
}

func getSheetFilePath(sheetName string) string {
	return filepath.Join(dataDir, sheetName+".json")
}

func ensureDataDir() error {
	return os.MkdirAll(dataDir, 0755)
}

/* Types of Cells */
const (
	ValueCell = iota
	ScriptCell
	ComboBoxCell
	MultipleSelectionCell
)

type Cell struct {
	Value string `json:"value,omitempty"`

	User   string `json:"user,omitempty"` // Last edited by
	CellID string `json:"cell_id,omitempty"`
	Locked bool   `json:"locked,omitempty"`

	Background string `json:"background,omitempty"`
	Bold       bool   `json:"bold,omitempty"`
	Italic     bool   `json:"italic,omitempty"`

	CellType int `json:"cell_type,omitempty"` // 0 = value, 1 = script, 2 = combo box, 3 = multiple selection. If not set, default to value cell

	/* Script associated elements*/
	Script       string `json:"script,omitempty"`        //python script
	ScriptOutput string `json:"script_output,omitempty"` //raw output of the script is stored

	/*if output is a matrix and if the dimension matches the Spans. element[0]0] will be written in Value field of current cell. And remaining elements result will be written over Value field of adjacent cells depending on row and column offset*/
	ScriptOutput_RowSpan int `json:"script_output_row_span,omitempty"`
	ScriptOutput_ColSpan int `json:"script_output_col_span,omitempty"`

	/*used to value generated by scripts other than the script which depend on its own value. This value will be used as input by scripts which depend on its own value	*/
	Value_FromNonSelfScript string `json:"value_from_non_self_script,omitempty"`

	LockedBy string `json:"locked_by,omitempty"` // username of locker (e.g. "script-span <id>" for script-based locks)
	/*****************************/

	/*Combo box and multiple selection related fields*/
	/**Parameters for combo box and multiple selection types**/
	// for combo box or multiple selection, the list of options Each option is a map with "id" and "displayValue" keys.
	// For multiple selection, multiple options can be selected and ids will be stored  in the OptionSelected field.
	Options      []string `json:"options,omitempty"`
	OptionsRange string   `json:"options_range,omitempty"` // e.g. "A1:A10" to specify options from a range in the sheet
	//user will give either Options or OptionsRange. If OptionsRange is given, Options will be filled by reading the specified range and extracting values from it. This allows dynamic options based on sheet data.
	OptionsSelected []int `json:"option_selected,omitempty"` // for combo box, only one option can be selected and its index will be stored. For multiple selection, the list of selected option indices will be stored.
	//In the case of combo box, Options at index OptionsSelected[0] will be written to Value field.
	//In the case of multiple selection, Values of selected options will be concatenated with semi-comma and written to Value field.
	/*****************************/

}

type AuditEntry struct {
	Timestamp      time.Time `json:"timestamp"`
	User           string    `json:"user"`
	Action         string    `json:"action"` // e.g., "EDIT_CELL", "CREATE_SHEET"
	Details        string    `json:"details"`
	Row1           int       `json:"row"`
	Col1           string    `json:"col"`
	Row2           int       `json:"row2"`
	Col2           string    `json:"col2"`
	OldValue       string    `json:"old_value"`       // previous value
	NewValue       string    `json:"new_value"`       // new value
	ChangeReversed bool      `json:"change_reversed"` // true if a revert operation logged
}

type Permissions struct {
	Editors []string `json:"editors"`
}

type Sheet struct {
	Name        string                     `json:"name"`
	Owner       string                     `json:"owner"`
	ProjectName string                     `json:"project_name,omitempty"`
	Data        map[string]map[string]Cell `json:"data"` // Row -> Col -> Cell
	AuditLog    []AuditEntry               `json:"audit_log"`
	Permissions Permissions                `json:"permissions"`
	ColWidths   map[string]int             `json:"col_widths,omitempty"`
	RowHeights  map[string]int             `json:"row_heights,omitempty"`
	mu          sync.RWMutex
}

func (s *Sheet) IsEditor(user string) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if user == "" {
		return false
	}
	if user == s.Owner {
		return true
	}
	for _, e := range s.Permissions.Editors {
		if e == user {
			return true
		}
	}
	return false
}

type SheetManager struct {
	sheets map[string]*Sheet
	mu     sync.RWMutex

	pending      map[string]*pendingSave // key -> pending info
	saveInterval time.Duration           // debounce duration
	started      bool
	stopCh       chan struct{}

	scriptDeps   map[string][]ScriptIdentifier // "project/sheet" -> []ScriptIdentifier
	scriptDepsMu sync.RWMutex

	lastExecutedTime time.Time
	executeInterval  time.Duration

	CellsModifiedManuallyQueue   []CellIdentifier // Queue of scripts to execute, protected by CellsModifiedQueueMu
	CellsModifiedManuallyQueueMu sync.Mutex

	CellsModifiedByScriptQueue   []CellIdentifier // Queue of scripts to execute, protected by CellsModifiedByScriptQueueMu
	CellsModifiedByScriptQueueMu sync.Mutex

	ScriptsExecuted   []string
	ScriptsExecutedMu sync.Mutex

	// ROW_COL_UPDATE broadcast queue
	RowColUpdateQueue   []RowColUpdateItem // Queue of sheets to broadcast ROW_COL_UPDATED messages
	RowColUpdateQueueMu sync.Mutex

	OptionsRangeDeps   map[string][]CellIdentifier // "project/sheet" -> []CellIdentifier that have options depending on a range in that sheet
	OptionsRangeDepsMu sync.RWMutex
}

type RowColUpdateItem struct {
	ProjectName string
	SheetName   string
}

type CellIdentifier struct {
	ProjectName string
	sheetName   string
	row         string
	col         string
}

type pendingSave struct {
	sheet        *Sheet
	lastModified time.Time
}

// Helper to save a single sheet without locking the manager (caller must hold lock)
func (sm *SheetManager) saveSheetLocked(sheet *Sheet) {
	if err := ensureDataDir(); err != nil {
		log.Printf("Error creating data directory: %v", err)
		return
	}

	// Determine path based on project folder if present
	var dir string
	if sheet.ProjectName != "" {
		dir = filepath.Join(dataDir, sheet.ProjectName)
		if err := os.MkdirAll(dir, 0755); err != nil {
			log.Printf("Error creating project directory %s: %v", dir, err)
			return
		}
	} else {
		dir = dataDir
	}
	filePath := filepath.Join(dir, sheet.Name+".json")
	file, err := os.Create(filePath)
	if err != nil {
		log.Printf("Error saving sheet %s: %v", sheet.Name, err)
		return
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(sheet); err != nil {
		log.Printf("Error encoding sheet %s: %v", sheet.Name, err)
	}
	fmt.Printf("Sheet %s saved successfully at %s\n", sheet.Name, filePath)
}

// MarshalJSON implementation for Sheet to ensure thread-safe encoding
func (s *Sheet) MarshalJSON() ([]byte, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	type Alias Sheet
	return json.Marshal(&struct {
		*Alias
	}{
		Alias: (*Alias)(s),
	})
}

var globalSheetManager = &SheetManager{
	sheets:  make(map[string]*Sheet),
	pending: make(map[string]*pendingSave),
	// saveInterval will be set in initAsyncSaver
	stopCh:                     make(chan struct{}),
	started:                    false,
	scriptDeps:                 make(map[string][]ScriptIdentifier),
	lastExecutedTime:           time.Time{},
	executeInterval:            2 * time.Second, // default execute interval
	ScriptsExecuted:            []string{},
	CellsModifiedManuallyQueue: []CellIdentifier{},
	CellsModifiedByScriptQueue: []CellIdentifier{},
	RowColUpdateQueue:          []RowColUpdateItem{},
	OptionsRangeDeps:           make(map[string][]CellIdentifier),
}

// Initialize async saver once during startup
func init() {
	// Initialize embedded Python once at startup
	if _, err := getEmbeddedPython(); err != nil {
		log.Printf("Embedded Python init failed: %v", err)
	}
}

var (
	embeddedPy        *python.EmbeddedPython
	embeddedPyOnce    sync.Once
	embeddedPyInitErr error
)

// getEmbeddedPython initializes and returns a shared embedded Python interpreter.
// It extracts the embedded Python distribution to a temp dir on first use.
func getEmbeddedPython() (*python.EmbeddedPython, error) {
	var initErr error
	embeddedPyOnce.Do(func() {
		ep, err := python.NewEmbeddedPython("shared-spreadsheet")
		if err != nil {
			initErr = err
			embeddedPyInitErr = err
			return
		}

		libFiles, err := embed_util.NewEmbeddedFiles(data.Data, "python-lib")

		if err != nil {
			initErr = err
			embeddedPyInitErr = err
			return
		}
		fmt.Println("Extracting embedded Python libraries to:", libFiles.GetExtractedPath())
		ep.AddPythonPath(libFiles.GetExtractedPath())
		embeddedPy = ep
	})
	if initErr != nil {
		embeddedPyInitErr = initErr
		return nil, initErr
	}
	return embeddedPy, nil
}

func (sm *SheetManager) initAsyncSaver() {
	sm.mu.Lock()
	defer sm.mu.Unlock()
	if sm.started {
		return
	}
	if sm.saveInterval == 0 {
		sm.saveInterval = 5 * time.Second // default debounce window
	}
	sm.started = true
	go sm.flusher()
}

func (sm *SheetManager) flusher() {
	ticker := time.NewTicker(250 * time.Millisecond)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			now := time.Now()

			sm.CellsModifiedByScriptQueueMu.Lock()

			if len(sm.CellsModifiedByScriptQueue) == 0 {
				sm.CellsModifiedByScriptQueueMu.Unlock()

				// Process script execution queue
				sm.CellsModifiedManuallyQueueMu.Lock()
				if len(sm.CellsModifiedManuallyQueue) > 0 {
					//clearing ScriptsExecuted list
					sm.ScriptsExecutedMu.Lock()
					//fmt.Println("scripts executed(flusher)", sm.ScriptsExecuted)
					clear(sm.ScriptsExecuted)
					//fmt.Println("scripts executed after clear(flusher)", sm.ScriptsExecuted)
					sm.ScriptsExecutedMu.Unlock()
					toExec := sm.CellsModifiedManuallyQueue[0]
					//pop from queue
					sm.CellsModifiedManuallyQueue = sm.CellsModifiedManuallyQueue[1:]
					sm.CellsModifiedManuallyQueueMu.Unlock()
					//fmt.Println("Executing scripts for manually modified cell:", toExec)
					ExecuteDependentScripts(toExec.ProjectName, toExec.sheetName, toExec.row, toExec.col)
					// Update options for cells which have options depending on range in the sheet of modified cell
					updateOptionsForDependentCells(toExec.ProjectName, toExec.sheetName, toExec.row, toExec.col)

					continue
				} else {
					sm.CellsModifiedManuallyQueueMu.Unlock()
				}
			} else {
				toExec := sm.CellsModifiedByScriptQueue[0]
				//pop from queue
				sm.CellsModifiedByScriptQueue = sm.CellsModifiedByScriptQueue[1:]
				sm.CellsModifiedByScriptQueueMu.Unlock()
				//fmt.Println("Executing scripts for script modified cell:", toExec)
				ExecuteDependentScripts(toExec.ProjectName, toExec.sheetName, toExec.row, toExec.col)
				// Update options for cells which have options depending on range in the sheet of modified cell
				updateOptionsForDependentCells(toExec.ProjectName, toExec.sheetName, toExec.row, toExec.col)

				continue
			}

			// collect due items without holding lock during disk IO
			var toFlush []*Sheet
			sm.mu.Lock()
			for k, ps := range sm.pending {
				if now.Sub(ps.lastModified) >= sm.saveInterval {
					toFlush = append(toFlush, ps.sheet)
					delete(sm.pending, k)
				}
			}
			sm.mu.Unlock()
			// flush outside of lock
			if len(toFlush) > 0 {
				sm.mu.RLock()
				for _, s := range toFlush {
					sm.saveSheetLocked(s)
				}
				sm.mu.RUnlock()
			}

			// Process ROW_COL_UPDATE broadcast queue
			sm.RowColUpdateQueueMu.Lock()
			if len(sm.RowColUpdateQueue) > 0 {
				// Deduplicate sheets in queue - only keep unique project/sheet combinations
				seenSheets := make(map[string]bool)
				uniqueUpdates := make([]RowColUpdateItem, 0)

				for _, item := range sm.RowColUpdateQueue {
					key := item.ProjectName + "::" + item.SheetName
					if !seenSheets[key] {
						seenSheets[key] = true
						uniqueUpdates = append(uniqueUpdates, item)
					}
				}

				// Clear the queue
				sm.RowColUpdateQueue = []RowColUpdateItem{}
				sm.RowColUpdateQueueMu.Unlock()

				// Send ROW_COL_UPDATED messages for each unique sheet
				if globalHub != nil {
					for _, item := range uniqueUpdates {
						sheet := sm.GetSheetBy(item.SheetName, item.ProjectName)
						if sheet != nil {
							payload, _ := json.Marshal(sheet.SnapshotForClient())
							globalHub.broadcast <- &Message{
								Type:      "ROW_COL_UPDATED",
								SheetName: item.SheetName,
								Project:   item.ProjectName,
								Payload:   payload,
								User:      "system",
							}
						}
					}
				}
			} else {
				sm.RowColUpdateQueueMu.Unlock()
			}

			//Code to debug mutex deadlock issues

			{
				currentTime := time.Now()

				// Check SheetManager.mu
				if sm.mu.TryLock() {
					sm.mu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.mu (main mutex) is currently locked at %v", currentTime)
				}

				// Check SheetManager.scriptDepsMu
				if sm.scriptDepsMu.TryLock() {
					sm.scriptDepsMu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.scriptDepsMu is currently locked at %v", currentTime)
				}

				// Check SheetManager.OptionsRangeDepsMu
				if sm.OptionsRangeDepsMu.TryLock() {
					sm.OptionsRangeDepsMu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.OptionsRangeDepsMu is currently locked at %v", currentTime)
				}

				// Check SheetManager.CellsModifiedManuallyQueueMu
				if sm.CellsModifiedManuallyQueueMu.TryLock() {
					sm.CellsModifiedManuallyQueueMu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.CellsModifiedManuallyQueueMu is currently locked at %v", currentTime)
				}

				// Check SheetManager.CellsModifiedByScriptQueueMu
				if sm.CellsModifiedByScriptQueueMu.TryLock() {
					sm.CellsModifiedByScriptQueueMu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.CellsModifiedByScriptQueueMu is currently locked at %v", currentTime)
				}

				// Check SheetManager.ScriptsExecutedMu
				if sm.ScriptsExecutedMu.TryLock() {
					sm.ScriptsExecutedMu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.ScriptsExecutedMu is currently locked at %v", currentTime)
				}

				// Check SheetManager.RowColUpdateQueueMu
				if sm.RowColUpdateQueueMu.TryLock() {
					sm.RowColUpdateQueueMu.Unlock()
				} else {
					log.Printf("[MUTEX DEBUG] SheetManager.RowColUpdateQueueMu is currently locked at %v", currentTime)
				}

				// Check all sheet mutexes
				if sm.mu.TryRLock() {
					for _, sheet := range sm.sheets {
						if sheet.mu.TryLock() {
							sheet.mu.Unlock()
						} else {
							log.Printf("[MUTEX DEBUG] Sheet %s (Project: %s) mutex is currently locked at %v",
								sheet.Name, sheet.ProjectName, currentTime)
						}
					}
					sm.mu.RUnlock()
				}
			}

		case <-sm.stopCh:
			return
		}
	}
}

// QueueRowColUpdate adds a sheet to the ROW_COL_UPDATE broadcast queue
func (sm *SheetManager) QueueRowColUpdate(projectName, sheetName string) {
	sm.RowColUpdateQueueMu.Lock()
	defer sm.RowColUpdateQueueMu.Unlock()
	// Check if this sheet is already queued to avoid duplicates
	for _, item := range sm.RowColUpdateQueue {
		if item.ProjectName == projectName && item.SheetName == sheetName {
			return
		}
	}
	sm.RowColUpdateQueue = append(sm.RowColUpdateQueue, RowColUpdateItem{
		ProjectName: projectName,
		SheetName:   sheetName,
	})
}

// sheetKey builds a unique key combining project and sheet id.
func sheetKey(project, id string) string {
	if project == "" {
		return id
	}
	return project + "::" + id
}

func (sm *SheetManager) CreateSheet(name, owner, projectName string) *Sheet {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	sheet := &Sheet{
		Name:        name,
		Owner:       owner,
		ProjectName: projectName,
		Data:        make(map[string]map[string]Cell),
		ColWidths:   make(map[string]int),
		RowHeights:  make(map[string]int),
		Permissions: Permissions{
			Editors: []string{owner},
		},
		AuditLog: []AuditEntry{},
	}

	// Initial Audit (details left empty for persistence)
	sheet.AuditLog = append(sheet.AuditLog, AuditEntry{
		Timestamp: time.Now(),
		User:      owner,
		Action:    "CREATE_SHEET",
	})

	sm.sheets[sheetKey(projectName, name)] = sheet
	sm.saveSheetLocked(sheet) // Persist individual sheet
	return sheet
}

// GetSheetBy finds a sheet by name and project name.
func (sm *SheetManager) GetSheetBy(name, project string) *Sheet {
	sm.mu.RLock()
	defer sm.mu.RUnlock()
	// Try direct composite key first
	if s, ok := sm.sheets[sheetKey(project, name)]; ok {
		return s
	}
	// Fallback: iterate (handles legacy keys)
	for _, s := range sm.sheets {
		if s != nil && s.Name == name && s.ProjectName == project {
			return s
		}
	}
	return nil
}

// CopySheetToProject creates a copy of source sheet into target project.
// New name defaults to source name if empty.
func (sm *SheetManager) CopySheetToProject(sourceID, sourceProject, targetProject, newName, owner string) *Sheet {
	// Locate source
	src := sm.GetSheetBy(sourceID, sourceProject)
	if src == nil {
		return nil
	}
	// Build new sheet
	sm.mu.Lock()
	defer sm.mu.Unlock()
	if newName == "" {
		newName = src.Name
	}
	copySheet := &Sheet{
		Name:        newName,
		Owner:       owner,
		ProjectName: targetProject,
		Data:        make(map[string]map[string]Cell),
		ColWidths:   make(map[string]int),
		RowHeights:  make(map[string]int),
		Permissions: Permissions{Editors: []string{owner}},
		AuditLog:    append([]AuditEntry{}, src.AuditLog...),
	}
	// Deep copy data
	src.mu.RLock()
	for r, cols := range src.Data {
		copySheet.Data[r] = make(map[string]Cell, len(cols))
		for c, cell := range cols {
			copySheet.Data[r][c] = cell
		}
	}
	for k, v := range src.ColWidths {
		copySheet.ColWidths[k] = v
	}
	for k, v := range src.RowHeights {
		copySheet.RowHeights[k] = v
	}
	src.mu.RUnlock()
	// Register and persist
	sm.sheets[sheetKey(targetProject, newName)] = copySheet
	sm.saveSheetLocked(copySheet)
	return copySheet
}

// Simple ID generator
func generateID() string {
	return time.Now().Format("20060102150405")
}

func (s *Sheet) SetCell(row, col, value, user string, reverted bool) {
	s.mu.Lock()
	// defer s.mu.Unlock() // MOVED to explicit unlock before Save()

	if s.Data[row] == nil {
		s.Data[row] = make(map[string]Cell)
	}
	currentVal, exists := s.Data[row][col]
	// Prevent edits to locked cells
	if exists && currentVal.Locked {
		s.mu.Unlock()
		return
	}
	if exists && currentVal.Value == value {
		// No change
		s.mu.Unlock()
		return
	}
	// Enqueue for script execution if value is changed manually
	globalSheetManager.CellsModifiedManuallyQueueMu.Lock()

	globalSheetManager.CellsModifiedManuallyQueue = append(globalSheetManager.CellsModifiedManuallyQueue, CellIdentifier{
		ProjectName: s.ProjectName,
		sheetName:   s.Name,
		row:         row,
		col:         col,
	})
	globalSheetManager.CellsModifiedManuallyQueueMu.Unlock()
	// Preserve existing metadata on write (including script, cell type, and options)
	s.Data[row][col] = Cell{
		Value:                   value,
		Script:                  currentVal.Script,
		User:                    user,
		Locked:                  currentVal.Locked,
		LockedBy:                currentVal.LockedBy,
		Background:              currentVal.Background,
		Bold:                    currentVal.Bold,
		Italic:                  currentVal.Italic,
		CellType:                currentVal.CellType,
		Options:                 currentVal.Options,
		OptionsRange:            currentVal.OptionsRange,
		OptionsSelected:         currentVal.OptionsSelected,
		ScriptOutput:            currentVal.ScriptOutput,
		ScriptOutput_RowSpan:    currentVal.ScriptOutput_RowSpan,
		ScriptOutput_ColSpan:    currentVal.ScriptOutput_ColSpan,
		Value_FromNonSelfScript: currentVal.Value_FromNonSelfScript,
	}
	if reverted {
		// Mark the original EDIT_CELL entry as reverted instead of appending a new one
		// Find the latest matching edit for this cell where NewValue equals the current cell value prior to revert
		prevNew := currentVal.Value
		r1 := atoiSafe(row)
		for i := len(s.AuditLog) - 1; i >= 0; i-- {
			e := &s.AuditLog[i]
			if e.Action == "EDIT_CELL" && e.Row1 == r1 && e.Col1 == col && e.NewValue == prevNew && !e.ChangeReversed {
				e.ChangeReversed = true
				break
			}
		}
		// Do not append a new audit entry for revert
	} else {
		var oldVal string
		if exists {
			oldVal = currentVal.Value
		}
		cellChanges := make(map[string]cellChangesstruct)
		// Append edit entry, merging with the last same-user edit for this cell if present
		r1 := atoiSafe(row)
		cLabel := col
		key := row + "-" + cLabel
		cellChanges[key] = cellChangesstruct{
			rowNum: r1,
			colStr: cLabel,
			oldVal: oldVal,
			newVal: value,
			action: "EDIT_CELL",
			user:   user,
		}
		// Add merged audit entries before save
		addMergedAuditEntries(s, cellChanges)
		/*
			oldValForNew := ""
			if exists {
				oldValForNew = currentVal.Value
			}

			prevIdx := -1
			for i := len(s.AuditLog) - 1; i >= 0; i-- {
				entry := s.AuditLog[i]
				if entry.Action == "EDIT_CELL" && entry.Row1 == r1 && entry.Col1 == col {
					if entry.User == user && !entry.ChangeReversed {
						prevIdx = i
					}
					break
				}
			}
			if prevIdx >= 0 {
				// Only merge if previous log is within 24 hours
				if time.Since(s.AuditLog[prevIdx].Timestamp) < 24*time.Hour {
					oldValForNew = s.AuditLog[prevIdx].OldValue
					s.AuditLog = append(s.AuditLog[:prevIdx], s.AuditLog[prevIdx+1:]...)
				}
			}
			if oldValForNew != value {
				s.AuditLog = append(s.AuditLog, AuditEntry{
					Timestamp:      time.Now(),
					User:           user,
					Action:         "EDIT_CELL",
					Row1:           r1,
					Col1:           col,
					OldValue:       oldValForNew,
					NewValue:       value,
					ChangeReversed: false,
				})

			}
		*/
	}

	s.mu.Unlock() // Unlock BEFORE saving to avoid deadlock (Save -> MarshalJSON -> tries RLock)

	// Persist changes
	// Optimally we shouldn't save on every cell edit for performance, but for this task it ensures safety.
	globalSheetManager.SaveSheet(s)
}

// SetCellScript updates only the script attribute for a cell, preserving value and other metadata.
func (s *Sheet) SetCellScript(row, col, script, user string, reverted bool, rowSpan int, colSpan int) {
	s.mu.Lock()
	// ensure row map
	if s.Data[row] == nil {
		s.Data[row] = make(map[string]Cell)
	}
	currentVal, exists := s.Data[row][col]
	// Prevent edits to locked cells
	if exists && currentVal.Locked {
		s.mu.Unlock()
		return
	}
	// Audit only script change
	if reverted {
		prevNew := currentVal.Script
		r1 := atoiSafe(row)
		for i := len(s.AuditLog) - 1; i >= 0; i-- {
			e := &s.AuditLog[i]
			if e.Action == "EDIT_SCRIPT" && e.Row1 == r1 && e.Col1 == col && e.NewValue == prevNew && !e.ChangeReversed {
				e.ChangeReversed = true
				break
			}
		}
	} else {
		var oldScript string
		if exists {
			oldScript = currentVal.Script
		}

		cellChanges := make(map[string]cellChangesstruct)
		// Append edit entry, merging with the last same-user edit for this cell if present
		r1 := atoiSafe(row)
		cLabel := col
		key := row + "-" + cLabel
		cellChanges[key] = cellChangesstruct{
			rowNum: r1,
			colStr: cLabel,
			oldVal: oldScript,
			newVal: script,
			action: "EDIT_SCRIPT",
			user:   user,
		}
		// Add merged audit entries before save
		addMergedAuditEntries(s, cellChanges)
		/*
			prevIdx := -1
			r1 := atoiSafe(row)
			for i := len(s.AuditLog) - 1; i >= 0; i-- {
				entry := s.AuditLog[i]
				if entry.Action == "EDIT_SCRIPT" && entry.Row1 == r1 && entry.Col1 == col {
					if entry.User == user && !entry.ChangeReversed {
						prevIdx = i
					}
					break
				}
			}
			if prevIdx >= 0 {
				if time.Since(s.AuditLog[prevIdx].Timestamp) < 24*time.Hour {
					oldScript = s.AuditLog[prevIdx].OldValue
					s.AuditLog = append(s.AuditLog[:prevIdx], s.AuditLog[prevIdx+1:]...)
				}
			}
			if oldScript != script {
				s.AuditLog = append(s.AuditLog, AuditEntry{
					Timestamp:      time.Now(),
					User:           user,
					Action:         "EDIT_SCRIPT",
					Row1:           r1,
					Col1:           col,
					OldValue:       oldScript,
					NewValue:       script,
					ChangeReversed: false,
				})
			}
		*/
	}

	// Preserve existing metadata
	updated := currentVal
	updated.Script = script
	updated.User = user
	if !exists || exists && strings.TrimSpace(currentVal.CellID) == "" && strings.TrimSpace(script) != "" {
		updated.CellID = generateID()
		updated.CellType = ScriptCell
	}
	if exists && strings.TrimSpace(script) == "" {
		updated.CellType = ValueCell
	}
	// Normalize spans
	if rowSpan <= 0 {
		rowSpan = 1
	}
	if colSpan <= 0 {
		colSpan = 1
	}

	updated.ScriptOutput_RowSpan = rowSpan
	updated.ScriptOutput_ColSpan = colSpan
	s.Data[row][col] = updated

	// Update script dependencies
	cellID := updated.CellID
	s.mu.Unlock()

	// Update dependency map for this script
	globalSheetManager.UpdateScriptDependencies(s.ProjectName, s.Name, cellID, script, row, col)

	// Done updating script; save and execute
	globalSheetManager.SaveSheet(s)
	ExecuteCellScriptonChange(s.ProjectName, s.Name, row, col)
	//s.FillValueFromScriptOutput(row, col)
}

// SetCellStyle updates style attributes for a cell while preserving value and lock metadata.
func (s *Sheet) SetCellStyle(row, col, background string, bold, italic bool, user string) {
	s.mu.Lock()
	if s.Data[row] == nil {
		s.Data[row] = make(map[string]Cell)
	}
	current, exists := s.Data[row][col]
	// Prevent edits to locked cells' style if locked
	if exists && current.Locked {
		s.mu.Unlock()
		return
	}
	// Apply style while preserving existing value and lock info
	updated := current
	updated.User = user
	updated.Background = background
	updated.Bold = bold
	updated.Italic = italic
	s.Data[row][col] = updated

	if exists {
		s.AuditLog = append(s.AuditLog, AuditEntry{
			Timestamp:      time.Now(),
			User:           user,
			Action:         "STYLE_CELL",
			Row1:           atoiSafe(row),
			Col1:           col,
			ChangeReversed: false,
		})
	} else {
		s.AuditLog = append(s.AuditLog, AuditEntry{
			Timestamp:      time.Now(),
			User:           user,
			Action:         "STYLE_CELL",
			Row1:           atoiSafe(row),
			Col1:           col,
			ChangeReversed: false,
		})
	}
	s.mu.Unlock()
	globalSheetManager.SaveSheet(s)
}

// extractOptionsFromRange parses a range like "A1:A10" or "projectname/sheetid/A1:A10" and extracts values from those cells
func (s *Sheet) extractOptionsFromRange(rangeStr string) []string {
	rangeStr = strings.TrimSpace(rangeStr)
	if rangeStr == "" {
		return nil
	}

	// Check if it's a cross-sheet reference (project/.../sheetid/A1:A10).
	// The range portion is always the last slash-segment; the sheet name is the second-to-last;
	// everything before that forms the project path (may contain slashes for subfolders).
	var targetSheet *Sheet
	var rangeOnly string

	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) >= 3 {
		// Cross-sheet reference: project/.../sheetid/A1:A10
		n := len(slashParts)
		rangeOnly = slashParts[n-1]
		refSheetName := slashParts[n-2]
		refProjectName := strings.Join(slashParts[:n-2], "/")

		// Get the referenced sheet
		targetSheet = globalSheetManager.GetSheetBy(refSheetName, refProjectName)
		if targetSheet == nil {
			return nil
		}
	} else {
		// Same-sheet reference: A1:A10
		targetSheet = s
		rangeOnly = rangeStr
	}

	// Parse range format: "A1:B10" or "A1:A10"
	parts := strings.Split(rangeOnly, ":")
	if len(parts) != 2 {
		return nil
	}

	// Parse start cell (e.g., "A1")
	startCell := strings.TrimSpace(parts[0])
	endCell := strings.TrimSpace(parts[1])

	// Extract column and row from start cell
	startCol := ""
	startRow := ""
	for i, ch := range startCell {
		if ch >= '0' && ch <= '9' {
			startCol = strings.ToUpper(startCell[:i])
			startRow = startCell[i:]
			break
		}
	}

	// Extract column and row from end cell
	endCol := ""
	endRow := ""
	for i, ch := range endCell {
		if ch >= '0' && ch <= '9' {
			endCol = strings.ToUpper(endCell[:i])
			endRow = endCell[i:]
			break
		}
	}

	if startCol == "" || startRow == "" || endCol == "" || endRow == "" {
		return nil
	}

	// Convert to indices
	startColIdx := colLabelToIndex(startCol)
	endColIdx := colLabelToIndex(endCol)
	startRowNum := atoiSafe(startRow)
	endRowNum := atoiSafe(endRow)

	if startColIdx == 0 || endColIdx == 0 || startRowNum == 0 || endRowNum == 0 {
		return nil
	}

	// Ensure start <= end
	if startColIdx > endColIdx {
		startColIdx, endColIdx = endColIdx, startColIdx
	}
	if startRowNum > endRowNum {
		startRowNum, endRowNum = endRowNum, startRowNum
	}

	// Lock the target sheet for reading
	targetSheet.mu.RLock()
	defer targetSheet.mu.RUnlock()

	// Extract values from the range only if it's a single row or single column
	var options []string
	isSingleRow := startRowNum == endRowNum
	isSingleColumn := startColIdx == endColIdx

	if isSingleRow || isSingleColumn {
		for rowNum := startRowNum; rowNum <= endRowNum; rowNum++ {
			rowStr := strconv.Itoa(rowNum)
			for colIdx := startColIdx; colIdx <= endColIdx; colIdx++ {
				colStr := indexToColLabel(colIdx)
				if targetSheet.Data[rowStr] != nil {
					if cell, exists := targetSheet.Data[rowStr][colStr]; exists {
						value := strings.TrimSpace(cell.Value)
						if value != "" {
							options = append(options, value)
						}
					}
				}
			}
		}
	}

	return options
}

// SetCellType updates cell type for a cell. Only owner can change cell type.
func (s *Sheet) SetCellType(row, col string, cellType int, options []string, optionsRange string, user string) bool {
	s.mu.Lock()
	//defer s.mu.Unlock()

	// Only owner can change cell type
	if user != s.Owner {
		s.mu.Unlock()
		return false
	}

	if s.Data[row] == nil {
		s.Data[row] = make(map[string]Cell)
	}

	current := s.Data[row][col]
	s.mu.Unlock()
	// If optionsRange is provided, extract options from the specified range
	if optionsRange != "" {
		extractedOptions := s.extractOptionsFromRange(optionsRange)
		if len(extractedOptions) > 0 {
			options = extractedOptions
		}
	}
	s.mu.Lock()
	// Update cell type and options
	current.CellType = cellType
	current.Options = options
	current.OptionsRange = optionsRange
	current.User = user

	// Clear selected options when changing cell type
	if cellType != ComboBoxCell && cellType != MultipleSelectionCell {
		current.OptionsSelected = nil
	}

	s.Data[row][col] = current

	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp:      time.Now(),
		User:           user,
		Action:         "CHANGE_CELL_TYPE",
		Row1:           atoiSafe(row),
		Col1:           col,
		ChangeReversed: false,
	})
	s.mu.Unlock()

	// Update OptionsRange dependencies
	globalSheetManager.UpdateOptionsRangeDependencies(s.ProjectName, s.Name, row, col, optionsRange)

	globalSheetManager.SaveSheet(s)
	return true
}

// SetCellOptionSelected updates the selected options for a ComboBox or MultipleSelection cell
func (s *Sheet) SetCellOptionSelected(row, col string, optionSelected []int) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.Data[row] == nil {
		s.Data[row] = make(map[string]Cell)
	}

	current := s.Data[row][col]
	current.OptionsSelected = optionSelected
	s.Data[row][col] = current
}

// IsCellLocked returns whether the given cell is locked.
func (s *Sheet) IsCellLocked(row, col string) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if s.Data[row] == nil {
		return false
	}
	c, ok := s.Data[row][col]
	if !ok {
		return false
	}
	return c.Locked
}

// LockCell locks a cell. Only the sheet owner may lock.
func (s *Sheet) LockCell(row, col, user string) bool {
	s.mu.Lock()
	//defer s.mu.Unlock()
	if user != s.Owner {
		s.mu.Unlock()
		return false
	}
	if s.Data[row] == nil {
		s.Data[row] = make(map[string]Cell)
	}
	cell := s.Data[row][col]
	if cell.Locked {
		s.mu.Unlock()
		return true // already locked
	}
	cell.Locked = true
	cell.LockedBy = user
	s.Data[row][col] = cell
	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp:      time.Now(),
		User:           user,
		Action:         "LOCK_CELL",
		Row1:           atoiSafe(row),
		Col1:           col,
		ChangeReversed: false,
	})
	s.mu.Unlock()
	// Save after unlock via manager
	go globalSheetManager.SaveSheet(s)
	return true
}

// UnlockCell unlocks a cell. Only the sheet owner may unlock.
func (s *Sheet) UnlockCell(row, col, user string) bool {
	s.mu.Lock()
	//defer s.mu.Unlock()
	if user != s.Owner {
		s.mu.Unlock()
		return false
	}
	cell, ok := s.Data[row][col]
	if !ok {
		s.mu.Unlock()
		return false
	}
	if !cell.Locked {
		s.mu.Unlock()
		return true // already unlocked
	}
	cell.Locked = false
	cell.LockedBy = ""
	s.Data[row][col] = cell
	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp:      time.Now(),
		User:           user,
		Action:         "UNLOCK_CELL",
		Row1:           atoiSafe(row),
		Col1:           col,
		ChangeReversed: false,
	})
	s.mu.Unlock()
	// Save after unlock via manager
	go globalSheetManager.SaveSheet(s)
	return true
}

func (s *Sheet) SetColWidth(col string, width int, user string) {
	s.mu.Lock()
	// ensure map
	if s.ColWidths == nil {
		s.ColWidths = make(map[string]int)
	}
	s.ColWidths[col] = width

	s.mu.Unlock()

	globalSheetManager.SaveSheet(s)
}

func (s *Sheet) SetRowHeight(row string, height int, user string) {
	s.mu.Lock()
	if s.RowHeights == nil {
		s.RowHeights = make(map[string]int)
	}
	s.RowHeights[row] = height

	s.mu.Unlock()

	globalSheetManager.SaveSheet(s)
}

// UpdatePermissions sets editors list; only owner may change settings.
// Ensures owner is always in editors.
func (s *Sheet) UpdatePermissions(editors []string, performedBy string) bool {
	s.mu.Lock()
	//defer s.mu.Unlock()
	if performedBy != s.Owner {
		s.mu.Unlock()
		return false
	}
	// dedupe helpers
	uniq := func(in []string) []string {
		m := make(map[string]struct{})
		out := make([]string, 0, len(in))
		for _, v := range in {
			if v == "" {
				continue
			}
			if _, ok := m[v]; !ok {
				m[v] = struct{}{}
				out = append(out, v)
			}
		}
		s.mu.Unlock()
		return out
	}
	editors = uniq(editors)
	// Ensure owner in editors
	hasOwner := false
	for _, e := range editors {
		if e == s.Owner {
			hasOwner = true
			break
		}
	}
	if !hasOwner {
		editors = append(editors, s.Owner)
	}

	s.Permissions.Editors = editors
	s.mu.Unlock()
	go globalSheetManager.SaveSheet(s)
	// Log only in project audit
	globalProjectAuditManager.Append(s.ProjectName, performedBy, "UPDATE_SHEET_PERMISSIONS", fmt.Sprintf("For Sheet %s Editors: %v", s.Name, editors))
	return true
}

// TransferOwnership changes the owner to newOwner; only current owner may transfer.
// New owner is ensured in editors list.
func (s *Sheet) TransferOwnership(newOwner, performedBy string) bool {
	s.mu.Lock()
	//defer s.mu.Unlock()
	if performedBy != s.Owner {
		s.mu.Unlock()
		return false
	}
	old := s.Owner
	if newOwner == "" || newOwner == old {
		s.mu.Unlock()
		return false
	}
	s.Owner = newOwner
	// Ensure new owner in editors
	found := false
	for _, e := range s.Permissions.Editors {
		if e == newOwner {
			found = true
			break
		}
	}
	if !found {
		s.Permissions.Editors = append(s.Permissions.Editors, newOwner)
	}
	go globalSheetManager.SaveSheet(s)
	s.mu.Unlock()
	// Log only in project audit
	globalProjectAuditManager.Append(s.ProjectName, performedBy, "TRANSFER_SHEET_OWNERSHIP", fmt.Sprintf("For Sheet %s Owner changed from %s to %s", s.Name, old, newOwner))
	return true
}

// InsertRowBelow inserts a new empty row directly below `targetRowStr`, shifting subsequent rows (data and heights) down by one.
// Returns true if an insertion occurred.
func (s *Sheet) InsertRowBelow(targetRowStr, user string) bool {
	var targetRow int
	if _, err := fmt.Sscanf(targetRowStr, "%d", &targetRow); err != nil {
		return false
	}
	insertRow := targetRow + 1

	s.mu.Lock()

	// Shift existing rows [insertRow..] down by 1
	maxRow := 0
	for rowKey := range s.Data {
		var r int
		if _, err := fmt.Sscanf(rowKey, "%d", &r); err == nil {
			if r > maxRow {
				maxRow = r
			}
		}
	}
	for r := maxRow; r >= insertRow; r-- {
		fromKey := itoa(r)
		toKey := itoa(r + 1)
		if rowData, ok := s.Data[fromKey]; ok {
			delete(s.Data, fromKey)
			s.Data[toKey] = rowData
		} else {
			delete(s.Data, toKey)
		}
	}

	// Ensure the new row exists but empty
	newKey := itoa(insertRow)
	if s.Data == nil {
		s.Data = make(map[string]map[string]Cell)
	}
	if _, ok := s.Data[newKey]; !ok {
		s.Data[newKey] = make(map[string]Cell)
	}

	// Shift RowHeights
	if s.RowHeights == nil {
		s.RowHeights = make(map[string]int)
	}
	maxHeightRow := 0
	for rowKey := range s.RowHeights {
		var r int
		if _, err := fmt.Sscanf(rowKey, "%d", &r); err == nil {
			if r > maxHeightRow {
				maxHeightRow = r
			}
		}
	}
	for r := maxHeightRow; r >= insertRow; r-- {
		fromKey := itoa(r)
		toKey := itoa(r + 1)
		if h, ok := s.RowHeights[fromKey]; ok {
			delete(s.RowHeights, fromKey)
			s.RowHeights[toKey] = h
		} else {
			delete(s.RowHeights, toKey)
		}
	}
	// New row height defaults to existing height of target row, if any
	if h, ok := s.RowHeights[targetRowStr]; ok {
		s.RowHeights[newKey] = h
	}
	// Adjust audit log row references for rows at or below the inserted position
	s.adjustAuditRowsOnInsert(insertRow)

	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp: time.Now(),
		User:      user,
		Action:    "INSERT_ROW",
		Row1:      insertRow,
	})
	s.mu.Unlock()
	// Adjust script tags in cells for row insertion
	s.adjustScriptTagsOnInsertRow(insertRow)
	// Adjust OptionsRange references in cells for row insertion
	s.adjustOptionsRangeOnInsertRow(insertRow)

	// If the target row contains cells locked by a script span, re-run those scripts
	if rowMap, ok := s.Data[targetRowStr]; ok {
		lockedIDs := []string{}
		for _, cell := range rowMap {
			if cell.Locked && strings.HasPrefix(cell.LockedBy, "script-span ") {
				id := strings.TrimSpace(strings.TrimPrefix(cell.LockedBy, "script-span "))
				if id != "" {
					index := slices.Index(lockedIDs, id)
					if index == -1 {
						lockedIDs = append(lockedIDs, id)
					}
				}
			}
		}
		for _, id := range lockedIDs {
			startRow, startCol := "", ""
			for rKey, cols := range s.Data {
				for cKey, c := range cols {
					if strings.TrimSpace(c.CellID) == id {
						startRow = rKey
						startCol = cKey
						break
					}
				}
				if startRow != "" {
					break
				}
			}
			if startRow != "" && startCol != "" {
				ExecuteCellScriptonChange(s.ProjectName, s.Name, startRow, startCol)
			}
		}
	}

	globalSheetManager.SaveSheet(s)
	return true
}

// DeleteRowAt removes the row at rowStr and shifts subsequent rows up by one
func (s *Sheet) DeleteRowAt(rowStr, user string) bool {
	var row int
	if _, err := fmt.Sscanf(rowStr, "%d", &row); err != nil || row <= 0 {
		return false
	}
	s.mu.Lock()
	// Determine max row
	maxRow := 0
	for rowKey := range s.Data {
		var r int
		if _, err := fmt.Sscanf(rowKey, "%d", &r); err == nil {
			if r > maxRow {
				maxRow = r
			}
		}
	}
	// Remove the target row
	delete(s.Data, rowStr)
	// Shift rows [row+1..maxRow] up by 1
	for r := row + 1; r <= maxRow; r++ {
		fromKey := itoa(r)
		toKey := itoa(r - 1)
		if rowData, ok := s.Data[fromKey]; ok {
			delete(s.Data, fromKey)
			s.Data[toKey] = rowData
		} else {
			delete(s.Data, toKey)
		}
	}
	// RowHeights shift
	if s.RowHeights == nil {
		s.RowHeights = make(map[string]int)
	}
	maxHeightRow := 0
	for rowKey := range s.RowHeights {
		var r int
		if _, err := fmt.Sscanf(rowKey, "%d", &r); err == nil {
			if r > maxHeightRow {
				maxHeightRow = r
			}
		}
	}
	delete(s.RowHeights, rowStr)
	for r := row + 1; r <= maxHeightRow; r++ {
		fromKey := itoa(r)
		toKey := itoa(r - 1)
		if h, ok := s.RowHeights[fromKey]; ok {
			delete(s.RowHeights, fromKey)
			s.RowHeights[toKey] = h
		} else {
			delete(s.RowHeights, toKey)
		}
	}
	// Adjust audit logs for deletion
	s.adjustAuditRowsOnDelete(row)

	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp: time.Now(),
		User:      user,
		Action:    "DELETE_ROW",
		Row1:      row,
	})

	s.mu.Unlock()
	// Adjust script tags in cells for row deletion
	s.adjustScriptTagsOnDeleteRow(row)
	// Adjust OptionsRange references in cells for row deletion
	s.adjustOptionsRangeOnDeleteRow(row)
	globalSheetManager.SaveSheet(s)
	return true
}

// MoveRowBelow moves the row `fromRowStr` to be directly below `targetRowStr`.
// It shifts the intervening rows accordingly and preserves cell contents and row heights.
// Returns true if a move occurred.
func (s *Sheet) MoveRowBelow(fromRowStr, targetRowStr, user string) bool {
	// Parse integers
	var fromRow, targetRow int
	if _, err := fmt.Sscanf(fromRowStr, "%d", &fromRow); err != nil {
		return false
	}
	if _, err := fmt.Sscanf(targetRowStr, "%d", &targetRow); err != nil {
		return false
	}

	destIndex := targetRow + 1
	if destIndex == fromRow { // no-op
		return false
	}
	if fromRow < destIndex {
		destIndex-- // Adjust for removal before insertion
	}
	s.mu.Lock()
	// Prevent cutting a row containing locked cells
	if rowMap, ok := s.Data[fromRowStr]; ok {
		for _, cell := range rowMap {
			if cell.Locked {
				s.mu.Unlock()
				return false
			}
		}
	}
	// Snapshot cells for affected range
	start := fromRow
	end := destIndex
	if start > end {
		start, end = end, start
	}

	cellsByRowBefore := make(map[int]map[string]Cell)
	for r := start; r <= end; r++ {
		rowKey := itoa(r)
		if m, ok := s.Data[rowKey]; ok {
			clone := make(map[string]Cell, len(m))
			for c, cell := range m {
				clone[c] = cell
			}
			cellsByRowBefore[r] = clone
		} else {
			cellsByRowBefore[r] = make(map[string]Cell)
		}
	}

	savedRowCells := cellsByRowBefore[fromRow]

	// Helper to clear a row
	clearRow := func(row int) {
		rowKey := itoa(row)
		delete(s.Data, rowKey)
	}

	// Perform shifts
	if fromRow < destIndex {
		// Move down: shift [fromRow+1..destIndex] up by 1
		for k := fromRow + 1; k <= destIndex; k++ {
			target := k - 1
			clearRow(target)
			fromMap := cellsByRowBefore[k]
			if len(fromMap) > 0 {
				s.Data[itoa(target)] = make(map[string]Cell, len(fromMap))
				for col, cell := range fromMap {
					s.Data[itoa(target)][col] = cell
				}
			}
		}
		// Place saved row at destIndex
		clearRow(destIndex)
		if len(savedRowCells) > 0 {
			s.Data[itoa(destIndex)] = make(map[string]Cell, len(savedRowCells))
			for col, cell := range savedRowCells {
				s.Data[itoa(destIndex)][col] = cell
			}
		}
	} else {
		// Move up: shift [destIndex..fromRow-1] down by 1
		for k := fromRow - 1; k >= destIndex; k-- {
			target := k + 1
			clearRow(target)
			fromMap := cellsByRowBefore[k]
			if len(fromMap) > 0 {
				s.Data[itoa(target)] = make(map[string]Cell, len(fromMap))
				for col, cell := range fromMap {
					s.Data[itoa(target)][col] = cell
				}
			}
		}
		// Place saved row at destIndex
		clearRow(destIndex)
		if len(savedRowCells) > 0 {
			s.Data[itoa(destIndex)] = make(map[string]Cell, len(savedRowCells))
			for col, cell := range savedRowCells {
				s.Data[itoa(destIndex)][col] = cell
			}
		}
	}

	// Update RowHeights
	if s.RowHeights == nil {
		s.RowHeights = make(map[string]int)
	}
	newHeights := make(map[string]int, len(s.RowHeights))
	for k, v := range s.RowHeights {
		newHeights[k] = v
	}
	if fromRow < destIndex {
		for k := fromRow + 1; k <= destIndex; k++ {
			newHeights[itoa(k-1)] = s.RowHeights[itoa(k)]
		}
		newHeights[itoa(destIndex)] = s.RowHeights[itoa(fromRow)]
	} else {
		for k := fromRow - 1; k >= destIndex; k-- {
			newHeights[itoa(k+1)] = s.RowHeights[itoa(k)]
		}
		newHeights[itoa(destIndex)] = s.RowHeights[itoa(fromRow)]
	}
	s.RowHeights = newHeights
	// Adjust audit log rows according to move mapping
	s.adjustAuditRowsOnMove(fromRow, destIndex)
	// Audit entry
	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp: time.Now(),
		User:      user,
		Action:    "MOVE_ROW",
		Row1:      fromRow,
		Row2:      destIndex,
	})
	s.mu.Unlock()

	// Adjust script tags in cells for row move
	s.adjustScriptTagsOnMoveRow(fromRow, destIndex)
	// Adjust OptionsRange references in cells for row move
	s.adjustOptionsRangeOnMoveRow(fromRow, destIndex)

	// Save after unlock
	globalSheetManager.SaveSheet(s)
	return true
}

// MoveColumnRight moves the column `fromColStr` to be directly right of `targetColStr`.
// It shifts the intervening columns accordingly and preserves cell contents and column widths.
// Returns true if a move occurred.
func (s *Sheet) MoveColumnRight(fromColStr, targetColStr, user string) bool {
	// Convert column labels to indices (A, B, C, ...)
	toColIdx := func(label string) int {
		idx := 0
		for i := 0; i < len(label); i++ {
			idx = idx*26 + int(label[i]-'A'+1)
		}
		return idx
	}
	toColLabel := func(idx int) string {
		label := ""
		for idx > 0 {
			idx--
			b := byte(int('A') + (idx % 26))
			label = string([]byte{b}) + label
			idx /= 26
		}
		return label
	}

	fromIdx := toColIdx(fromColStr)
	targetIdx := toColIdx(targetColStr)
	if fromIdx == 0 || targetIdx == 0 {
		return false
	}
	destIdx := targetIdx + 1
	if destIdx == fromIdx {
		return false
	}
	if fromIdx < destIdx {
		destIdx-- // Adjust for removal before insertion
	}

	s.mu.Lock()
	// Prevent cutting a column containing any locked cell
	for _, rowMap := range s.Data {
		if cell, ok := rowMap[fromColStr]; ok {
			if cell.Locked {
				s.mu.Unlock()
				return false
			}
		}
	}
	// Find all affected columns
	start := fromIdx
	end := destIdx
	if start > end {
		start, end = end, start
	}

	// Snapshot cells for affected columns
	cellsByColBefore := make(map[int]map[string]Cell)
	for c := start; c <= end; c++ {
		colLabel := toColLabel(c)
		colCells := make(map[string]Cell)
		for rowKey, rowMap := range s.Data {
			if cell, ok := rowMap[colLabel]; ok {
				colCells[rowKey] = cell
			}
		}
		cellsByColBefore[c] = colCells
	}
	savedColCells := cellsByColBefore[fromIdx]

	// Helper to clear a column
	clearCol := func(colIdx int) {
		colLabel := toColLabel(colIdx)
		for _, rowMap := range s.Data {
			delete(rowMap, colLabel)
		}
	}

	// Perform shifts
	if fromIdx < destIdx {
		// Move right: shift [fromIdx+1..destIdx] left by 1
		for k := fromIdx + 1; k <= destIdx; k++ {
			target := k - 1
			clearCol(target)
			fromMap := cellsByColBefore[k]
			for rowKey, cell := range fromMap {
				if s.Data[rowKey] == nil {
					s.Data[rowKey] = make(map[string]Cell)
				}
				s.Data[rowKey][toColLabel(target)] = cell
			}
		}
		// Place saved col at destIdx
		clearCol(destIdx)
		for rowKey, cell := range savedColCells {
			if s.Data[rowKey] == nil {
				s.Data[rowKey] = make(map[string]Cell)
			}
			s.Data[rowKey][toColLabel(destIdx)] = cell
		}
	} else {
		// Move left: shift [destIdx..fromIdx-1] right by 1
		for k := fromIdx - 1; k >= destIdx; k-- {
			target := k + 1
			clearCol(target)
			fromMap := cellsByColBefore[k]
			for rowKey, cell := range fromMap {
				if s.Data[rowKey] == nil {
					s.Data[rowKey] = make(map[string]Cell)
				}
				s.Data[rowKey][toColLabel(target)] = cell
			}
		}
		// Place saved col at destIdx
		clearCol(destIdx)
		for rowKey, cell := range savedColCells {
			if s.Data[rowKey] == nil {
				s.Data[rowKey] = make(map[string]Cell)
			}
			s.Data[rowKey][toColLabel(destIdx)] = cell
		}
	}

	// Update ColWidths
	if s.ColWidths == nil {
		s.ColWidths = make(map[string]int)
	}
	newWidths := make(map[string]int, len(s.ColWidths))
	for k, v := range s.ColWidths {
		newWidths[k] = v
	}
	if fromIdx < destIdx {
		for k := fromIdx + 1; k <= destIdx; k++ {
			newWidths[toColLabel(k-1)] = s.ColWidths[toColLabel(k)]
		}
		newWidths[toColLabel(destIdx)] = s.ColWidths[toColLabel(fromIdx)]
	} else {
		for k := fromIdx - 1; k >= destIdx; k-- {
			newWidths[toColLabel(k+1)] = s.ColWidths[toColLabel(k)]
		}
		newWidths[toColLabel(destIdx)] = s.ColWidths[toColLabel(fromIdx)]
	}
	s.ColWidths = newWidths
	// Adjust audit log columns according to move mapping
	s.adjustAuditColsOnMove(fromIdx, destIdx)
	// Audit entry
	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp: time.Now(),
		User:      user,
		Action:    "MOVE_COL",
		Col1:      fromColStr,
		Col2:      toColLabel(destIdx),
	})

	s.mu.Unlock()
	// Adjust script tags in cells for column move
	s.adjustScriptTagsOnMoveCol(fromIdx, destIdx)
	// Adjust OptionsRange references in cells for column move
	s.adjustOptionsRangeOnMoveCol(fromIdx, destIdx)

	// Save after unlock
	globalSheetManager.SaveSheet(s)
	return true
}

// InsertColumnRight inserts a new empty column directly to the right of `targetColStr`,
// shifting subsequent columns (data and widths) right by one. Returns true if insertion occurred.
func (s *Sheet) InsertColumnRight(targetColStr, user string) bool {
	// Reuse the same helpers as MoveColumnRight
	toColIdx := func(label string) int {
		idx := 0
		for i := 0; i < len(label); i++ {
			idx = idx*26 + int(label[i]-'A'+1)
		}
		return idx
	}
	toColLabel := func(idx int) string {
		label := ""
		for idx > 0 {
			idx--
			b := byte(int('A') + (idx % 26))
			label = string([]byte{b}) + label
			idx /= 26
		}
		return label
	}

	targetIdx := toColIdx(targetColStr)
	// Support inserting to the left of the first column when target is empty/invalid
	var insertIdx int
	if targetIdx == 0 {
		insertIdx = 1
	} else {
		insertIdx = targetIdx + 1
	}

	s.mu.Lock()

	// Determine current max column index based on ColWidths and Data
	maxIdx := 0
	for col := range s.ColWidths {
		if idx := toColIdx(col); idx > maxIdx {
			maxIdx = idx
		}
	}
	for _, rowMap := range s.Data {
		for col := range rowMap {
			if idx := toColIdx(col); idx > maxIdx {
				maxIdx = idx
			}
		}
	}

	// Shift cells for all rows from right to left
	for idx := maxIdx; idx >= insertIdx; idx-- {
		fromLabel := toColLabel(idx)
		toLabel := toColLabel(idx + 1)
		for rowKey, rowMap := range s.Data {
			if cell, ok := rowMap[fromLabel]; ok {
				if s.Data[rowKey] == nil {
					s.Data[rowKey] = make(map[string]Cell)
				}
				rowMap[toLabel] = cell
				delete(rowMap, fromLabel)
			} else {
				delete(rowMap, toLabel)
			}
		}
	}

	// Ensure the new column exists as empty in all rows (optional but consistent)
	newLabel := toColLabel(insertIdx)
	for rowKey := range s.Data {
		if s.Data[rowKey] == nil {
			s.Data[rowKey] = make(map[string]Cell)
		}
		if _, ok := s.Data[rowKey][newLabel]; !ok {
			s.Data[rowKey][newLabel] = Cell{}
		}
	}

	// Shift ColWidths
	if s.ColWidths == nil {
		s.ColWidths = make(map[string]int)
	}
	maxWidthIdx := 0
	for col := range s.ColWidths {
		if idx := toColIdx(col); idx > maxWidthIdx {
			maxWidthIdx = idx
		}
	}
	for idx := maxWidthIdx; idx >= insertIdx; idx-- {
		fromLabel := toColLabel(idx)
		toLabel := toColLabel(idx + 1)
		if w, ok := s.ColWidths[fromLabel]; ok {
			delete(s.ColWidths, fromLabel)
			s.ColWidths[toLabel] = w
		} else {
			delete(s.ColWidths, toLabel)
		}
	}
	// New column width defaults to existing width of target column, if any
	if w, ok := s.ColWidths[targetColStr]; ok {
		s.ColWidths[newLabel] = w
	}
	// Adjust audit log column references for columns at or beyond the inserted position
	s.adjustAuditColsOnInsert(insertIdx)

	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp:      time.Now(),
		User:           user,
		Action:         "INSERT_COL",
		Col1:           newLabel,
		ChangeReversed: false,
	})
	s.mu.Unlock()
	// Adjust script tags in cells for column insertion
	s.adjustScriptTagsOnInsertCol(insertIdx)
	// Adjust OptionsRange references in cells for column insertion
	s.adjustOptionsRangeOnInsertCol(insertIdx)
	// If the target column contains cells locked by a script span, re-run those scripts

	lockedIDs := []string{}
	for _, rowMap := range s.Data {
		if cell, ok := rowMap[targetColStr]; ok {
			if cell.Locked && strings.HasPrefix(cell.LockedBy, "script-span ") {
				id := strings.TrimSpace(strings.TrimPrefix(cell.LockedBy, "script-span "))
				if id != "" {
					index := slices.Index(lockedIDs, id)
					if index == -1 {

						lockedIDs = append(lockedIDs, id)
					}
				}
			}
		}
	}

	for _, id := range lockedIDs {
		startRow, startCol := "", ""
		//fmt.Printf("Locked ID: %s\n", id)
		for rKey, cols := range s.Data {
			for cKey, c := range cols {
				if strings.TrimSpace(c.CellID) == id {
					startRow = rKey
					startCol = cKey
					break
				}
			}
			if startRow != "" {
				break
			}
		}
		if startRow != "" && startCol != "" {
			ExecuteCellScriptonChange(s.ProjectName, s.Name, startRow, startCol)
		}
	}
	globalSheetManager.SaveSheet(s)
	return true
}

// DeleteColumnAt removes a column by label and shifts subsequent columns left by one
func (s *Sheet) DeleteColumnAt(colStr, user string) bool {
	insertIdx := colLabelToIndex(colStr)
	if insertIdx <= 0 {
		return false
	}
	s.mu.Lock()
	// Determine max column index
	maxIdx := 0
	for _, rowMap := range s.Data {
		for col := range rowMap {
			if idx := colLabelToIndex(col); idx > maxIdx {
				maxIdx = idx
			}
		}
	}
	// Remove target column
	for _, rowMap := range s.Data {
		delete(rowMap, colStr)
	}
	// Shift [insertIdx+1..maxIdx] left by 1
	for idx := insertIdx + 1; idx <= maxIdx; idx++ {
		fromLabel := indexToColLabel(idx)
		toLabel := indexToColLabel(idx - 1)
		for rowKey, rowMap := range s.Data {
			if cell, ok := rowMap[fromLabel]; ok {
				if s.Data[rowKey] == nil {
					s.Data[rowKey] = make(map[string]Cell)
				}
				rowMap[toLabel] = cell
				delete(rowMap, fromLabel)
			} else {
				delete(rowMap, toLabel)
			}
		}
	}
	// Shift ColWidths
	if s.ColWidths == nil {
		s.ColWidths = make(map[string]int)
	}
	maxWidthIdx := 0
	for col := range s.ColWidths {
		if idx := colLabelToIndex(col); idx > maxWidthIdx {
			maxWidthIdx = idx
		}
	}
	delete(s.ColWidths, colStr)
	for idx := insertIdx + 1; idx <= maxWidthIdx; idx++ {
		fromLabel := indexToColLabel(idx)
		toLabel := indexToColLabel(idx - 1)
		if w, ok := s.ColWidths[fromLabel]; ok {
			delete(s.ColWidths, fromLabel)
			s.ColWidths[toLabel] = w
		} else {
			delete(s.ColWidths, toLabel)
		}
	}
	// Adjust audit logs for deletion
	s.adjustAuditColsOnDelete(insertIdx)

	s.AuditLog = append(s.AuditLog, AuditEntry{
		Timestamp:      time.Now(),
		User:           user,
		Action:         "DELETE_COL",
		Col1:           colStr,
		ChangeReversed: false,
	})

	s.mu.Unlock()
	// Adjust script tags in cells for column deletion
	s.adjustScriptTagsOnDeleteCol(insertIdx)
	// Adjust OptionsRange references in cells for column deletion
	s.adjustOptionsRangeOnDeleteCol(insertIdx)
	globalSheetManager.SaveSheet(s)
	return true
}
func itoa(i int) string {
	return fmt.Sprintf("%d", i)
}

func atoiSafe(s string) int {
	var v int
	if _, err := fmt.Sscanf(s, "%d", &v); err != nil {
		return 0
	}
	return v
}

// Column helpers
func colLabelToIndex(label string) int {
	if label == "" {
		return 0
	}
	idx := 0
	for i := 0; i < len(label); i++ {
		ch := label[i]
		if ch < 'A' || ch > 'Z' {
			return 0
		}
		idx = idx*26 + int(ch-'A'+1)
	}
	return idx
}

func indexToColLabel(idx int) string {
	if idx <= 0 {
		return ""
	}
	label := ""
	for idx > 0 {
		idx--
		b := byte(int('A') + (idx % 26))
		label = string([]byte{b}) + label
		idx /= 26
	}
	return label
}

var (
	reCell = regexp.MustCompile(`(?i)cell\s+(\d+),([A-Z]+)`) // cell 12,C
	reRow  = regexp.MustCompile(`(?i)row\s+(\d+)`)           // row 12
	reCol  = regexp.MustCompile(`(?i)column\s+([A-Z]+)`)     // column C
)

// ensureEntryCoords tries to ensure Row/Col fields are populated for an entry by parsing Details if needed
func ensureEntryCoords(e *AuditEntry) {
	if e.Row1 == 0 || e.Col1 == "" {
		if m := reCell.FindStringSubmatch(e.Details); len(m) == 3 {
			var r int
			_, _ = fmt.Sscanf(m[1], "%d", &r)
			e.Row1 = r
			e.Col1 = m[2]
			return
		}
	}
	if e.Row1 == 0 {
		if m := reRow.FindStringSubmatch(e.Details); len(m) == 2 {
			var r int
			_, _ = fmt.Sscanf(m[1], "%d", &r)
			e.Row1 = r
		}
	}
	if e.Col1 == "" {
		if m := reCol.FindStringSubmatch(e.Details); len(m) == 2 {
			e.Col1 = m[1]
		}
	}
}

// replaceDetailCoords updates the coordinates present in Details if patterns are found
func replaceDetailCoords(details string, newRow int, newCol string) string {
	updated := details
	// Replace only the first occurrence of row and column to reflect the entry's coordinates
	if newRow > 0 {
		if loc := reRow.FindStringIndex(updated); loc != nil {
			// Replace entire match with "row <newRow>"
			updated = updated[:loc[0]] + fmt.Sprintf("row %d", newRow) + updated[loc[1]:]
		}
	}
	if newCol != "" {
		if loc := reCol.FindStringIndex(updated); loc != nil {
			updated = updated[:loc[0]] + fmt.Sprintf("column %s", newCol) + updated[loc[1]:]
		}
	}
	if newRow > 0 || newCol != "" {
		if reCell.MatchString(updated) {
			updated = reCell.ReplaceAllStringFunc(updated, func(s string) string {
				// Ignore s; replace using provided newRow/newCol when available
				// If one of them is missing, preserve original via captured groups
				m := reCell.FindStringSubmatch(s)
				rowStr, colStr := m[1], m[2]
				if newRow > 0 {
					rowStr = itoa(newRow)
				}
				if newCol != "" {
					colStr = newCol
				}
				return fmt.Sprintf("cell %s,%s", rowStr, colStr)
			})
		}
	}
	return updated
}

// computeAuditDetails constructs a user-friendly details string for an audit entry
// without persisting it. Uses structured fields from the entry and, when needed,
// sheet context (e.g., sheet name).
func computeAuditDetails(s *Sheet, e AuditEntry) string {
	switch e.Action {
	case "CREATE_SHEET":
		if s != nil {
			return "Created sheet " + s.Name
		}
		return "Created sheet"
	case "EDIT_CELL":
		r := e.Row1
		c := e.Col1
		if e.OldValue == "" {
			return fmt.Sprintf("Set cell %d,%s to %s", r, c, firstNChar(e.NewValue, 10))
		}
		return fmt.Sprintf("Changed cell %d,%s from %s to %s", r, c, firstNChar(e.OldValue, 10), firstNChar(e.NewValue, 10))
	case "EDIT_SCRIPT":
		r := e.Row1
		c := e.Col1
		if e.OldValue == "" {
			return fmt.Sprintf("Set script for cell %d,%s to %s", r, c, firstNChar(e.NewValue, 10))
		}
		return fmt.Sprintf("Changed script for cell %d,%s", r, c)
	case "STYLE_CELL":
		return fmt.Sprintf("Updated style for cell %d,%s", e.Row1, e.Col1)
	case "LOCK_CELL":
		return fmt.Sprintf("Locked cell %d,%s", e.Row1, e.Col1)
	case "UNLOCK_CELL":
		return fmt.Sprintf("Unlocked cell %d,%s", e.Row1, e.Col1)
	case "INSERT_ROW":
		return fmt.Sprintf("Inserted row %d", e.Row1)
	case "DELETE_ROW":
		return fmt.Sprintf("Deleted row %d", e.Row1)
	case "MOVE_ROW":
		if e.Row2 > 0 {
			return fmt.Sprintf("Moved row %d to row %d", e.Row1, e.Row2)
		}
		return fmt.Sprintf("Moved row %d", e.Row1)
	case "INSERT_COL":
		return fmt.Sprintf("Inserted column %s", e.Col1)
	case "DELETE_COL":
		return fmt.Sprintf("Deleted column %s", e.Col1)
	case "MOVE_COL":
		if e.Col2 != "" {
			return fmt.Sprintf("Moved column %s to right of column %s", e.Col1, e.Col2)
		}
		return fmt.Sprintf("Moved column %s", e.Col1)
	case "UPDATE_PERMISSIONS":
		return "Updated permissions"
	case "TRANSFER_OWNERSHIP":
		return "Transferred ownership"
	default:
		return e.Action
	}
}

// SnapshotForClient builds a copy of the sheet with audit Details filled for response
// without mutating or leaking internal state. This snapshot is safe to marshal/send.
func (s *Sheet) SnapshotForClient() *Sheet {
	s.mu.RLock()
	defer s.mu.RUnlock()

	// Deep copy data
	dataCopy := make(map[string]map[string]Cell, len(s.Data))
	for r, cols := range s.Data {
		inner := make(map[string]Cell, len(cols))
		for c, cell := range cols {
			inner[c] = cell
		}
		dataCopy[r] = inner
	}
	colWidthsCopy := make(map[string]int, len(s.ColWidths))
	for k, v := range s.ColWidths {
		colWidthsCopy[k] = v
	}
	rowHeightsCopy := make(map[string]int, len(s.RowHeights))
	for k, v := range s.RowHeights {
		rowHeightsCopy[k] = v
	}
	auditCopy := make([]AuditEntry, 0, len(s.AuditLog))
	for _, e := range s.AuditLog {
		e2 := e
		e2.Details = computeAuditDetails(s, e)
		auditCopy = append(auditCopy, e2)
	}

	snap := &Sheet{
		Name:        s.Name,
		Owner:       s.Owner,
		ProjectName: s.ProjectName,
		Data:        dataCopy,
		AuditLog:    auditCopy,
		Permissions: Permissions{Editors: append([]string(nil), s.Permissions.Editors...)},
		ColWidths:   colWidthsCopy,
		RowHeights:  rowHeightsCopy,
	}
	return snap
}

// adjustAuditRowsOnInsert increments row references for entries at or below insertRow
func (s *Sheet) adjustAuditRowsOnInsert(insertRow int) {
	for i := range s.AuditLog {
		e := &s.AuditLog[i]
		oldRow := e.Row1
		ensureEntryCoords(e)
		if e.Row1 >= insertRow && e.Row1 > 0 {
			e.Row1 = e.Row1 + 1
		}
		_ = oldRow // details left empty; no string rewrite
	}
}

// adjustAuditRowsOnMove adjusts row references for a row move from fromRow to destIndex
func (s *Sheet) adjustAuditRowsOnMove(fromRow, destIndex int) {
	for i := range s.AuditLog {
		e := &s.AuditLog[i]
		ensureEntryCoords(e)
		if e.Row1 == 0 {
			continue
		}
		old := e.Row1
		if fromRow < destIndex {
			if e.Row1 == fromRow {
				e.Row1 = destIndex
			} else if e.Row1 > fromRow && e.Row1 <= destIndex {
				e.Row1 = e.Row1 - 1
			}
		} else if fromRow > destIndex {
			if e.Row1 == fromRow {
				e.Row1 = destIndex
			} else if e.Row1 >= destIndex && e.Row1 < fromRow {
				e.Row1 = e.Row1 + 1
			}
		}
		_ = old // details left empty; no string rewrite
	}
}

// adjustAuditColsOnInsert increments column references for entries at or beyond insertIdx
func (s *Sheet) adjustAuditColsOnInsert(insertIdx int) {
	for i := range s.AuditLog {
		e := &s.AuditLog[i]
		oldCol := e.Col1
		ensureEntryCoords(e)
		idx := colLabelToIndex(e.Col1)
		if idx >= insertIdx && idx > 0 {
			idx = idx + 1
			e.Col1 = indexToColLabel(idx)
		}
		_ = oldCol // details left empty; no string rewrite
	}
}

// adjustAuditColsOnMove adjusts column references for a column move from fromIdx to destIdx
func (s *Sheet) adjustAuditColsOnMove(fromIdx, destIdx int) {
	for i := range s.AuditLog {
		e := &s.AuditLog[i]
		ensureEntryCoords(e)
		idx := colLabelToIndex(e.Col1)
		if idx == 0 {
			continue
		}
		oldIdx := idx
		if fromIdx < destIdx {
			if idx == fromIdx {
				idx = destIdx
			} else if idx > fromIdx && idx <= destIdx {
				idx = idx - 1
			}
		} else if fromIdx > destIdx {
			if idx == fromIdx {
				idx = destIdx
			} else if idx >= destIdx && idx < fromIdx {
				idx = idx + 1
			}
		}
		if idx != oldIdx {
			e.Col1 = indexToColLabel(idx)
		}
	}
}

// adjustAuditRowsOnDelete decrements row references for entries strictly above deleted row
func (s *Sheet) adjustAuditRowsOnDelete(deleteRow int) {
	for i := range s.AuditLog {
		e := &s.AuditLog[i]
		oldRow := e.Row1
		ensureEntryCoords(e)
		if e.Row1 > deleteRow {
			e.Row1 = e.Row1 - 1
		}
		_ = oldRow // details left empty; no string rewrite
	}
}

// adjustAuditColsOnDelete decrements column references for entries strictly right of deleted column
func (s *Sheet) adjustAuditColsOnDelete(deleteIdx int) {
	for i := range s.AuditLog {
		e := &s.AuditLog[i]
		oldCol := e.Col1
		ensureEntryCoords(e)
		idx := colLabelToIndex(e.Col1)
		if idx > deleteIdx {
			idx = idx - 1
			e.Col1 = indexToColLabel(idx)
		}
		_ = oldCol // details left empty; no string rewrite
	}
}

// adjustScriptTagsOnInsertRow increments row references in script tags for rows at or below insertRow
// This function updates both same-sheet references and cross-sheet references, and updates scriptDeps
func (s *Sheet) adjustScriptTagsOnInsertRow(insertRow int) {
	sameSheetPattern := regexp.MustCompile(`\{\{([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	crossSheetPattern := regexp.MustCompile(`\{\{([^/\{\}]+)/([^/\{\}]+)/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	s.mu.Lock()
	// Adjust same-sheet references in this sheet
	// Collect modified scripts to update dependencies after releasing sheet lock
	type depUpd struct{ project, sheet, cellID, script, row, col string }
	pending := make([]depUpd, 0)
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if cell.Script == "" {
				continue
			}

			newScript := sameSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
				submatches := sameSheetPattern.FindStringSubmatch(match)
				if len(submatches) < 3 {
					return match
				}

				col1 := submatches[1]
				row1 := atoiSafe(submatches[2])

				// Single cell reference {{A2}}
				if submatches[3] == "" || submatches[4] == "" {
					if row1 >= insertRow && row1 > 0 {
						row1++
					}
					return fmt.Sprintf("{{%s%d}}", col1, row1)
				}

				// Range reference {{A2:B3}}
				col2 := submatches[3]
				row2 := atoiSafe(submatches[4])

				if row1 >= insertRow && row1 > 0 {
					row1++
				}
				if row2 >= insertRow && row2 > 0 {
					row2++
				}

				return fmt.Sprintf("{{%s%d:%s%d}}", col1, row1, col2, row2)
			})

			if newScript != cell.Script {
				cell.Script = newScript
				s.Data[rowKey][colKey] = cell
				pending = append(pending, depUpd{s.ProjectName, s.Name, cell.CellID, newScript, rowKey, colKey})
			}
		}
	}
	s.mu.Unlock()
	// Update dependencies outside of sheet lock
	for _, u := range pending {
		globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s)
	}
	// Send ROW_COL_UPDATED message to clients if any scripts were modified in this sheet
	if len(pending) > 0 && globalHub != nil {
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}
	// Adjust cross-sheet references in sheets that reference this sheet
	// Use scriptDeps to find which sheets have dependencies on this sheet
	sheet_Key := s.ProjectName + "/" + s.Name
	globalSheetManager.scriptDepsMu.RLock()
	scriptIdentifiers, hasRefs := globalSheetManager.scriptDeps[sheet_Key]
	globalSheetManager.scriptDepsMu.RUnlock()

	if !hasRefs {
		return // No cross-sheet references to this sheet
	}

	// Collect unique sheets that reference this sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	globalSheetManager.mu.RLock()
	for _, si := range scriptIdentifiers {
		key := sheetKey(si.ScriptProjectName, si.ScriptSheetName)
		if !seenSheets[key] {
			if sheet, ok := globalSheetManager.sheets[key]; ok && sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[key] = true
			}
		}
	}
	globalSheetManager.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if cell.Script == "" {
					continue
				}

				newScript := crossSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
					submatches := crossSheetPattern.FindStringSubmatch(match)
					if len(submatches) < 5 {
						return match
					}

					refProject := submatches[1]
					refSheet := submatches[2]

					// Only adjust if referencing the current sheet
					if refProject != s.ProjectName || refSheet != s.Name {
						return match
					}

					col1 := submatches[3]
					row1 := atoiSafe(submatches[4])

					// Single cell reference {{project/sheet/A2}}
					if submatches[5] == "" || submatches[6] == "" {
						if row1 >= insertRow && row1 > 0 {
							row1++
						}
						return fmt.Sprintf("{{%s/%s/%s%d}}", refProject, refSheet, col1, row1)
					}

					// Range reference {{project/sheet/A2:B3}}
					col2 := submatches[5]
					row2 := atoiSafe(submatches[6])

					if row1 >= insertRow && row1 > 0 {
						row1++
					}
					if row2 >= insertRow && row2 > 0 {
						row2++
					}

					return fmt.Sprintf("{{%s/%s/%s%d:%s%d}}", refProject, refSheet, col1, row1, col2, row2)
				})

				if newScript != cell.Script {
					cell.Script = newScript
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		// Update dependencies for all modified scripts in this sheet without holding sheet lock
		if modified {
			// Snapshot scripts under read lock
			type depUpd2 struct{ project, sheet, cellID, script, row, col string }
			updList := make([]depUpd2, 0)
			sheet.mu.RLock()
			for rKey, rowMap := range sheet.Data {
				for cKey, cell := range rowMap {
					if cell.Script != "" {
						updList = append(updList, depUpd2{sheet.ProjectName, sheet.Name, cell.CellID, cell.Script, rKey, cKey})
					}
				}
			}
			sheet.mu.RUnlock()
			for _, u := range updList {
				globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
			}
			globalSheetManager.SaveSheet(sheet)
			// Send ROW_COL_UPDATED message to clients for this modified sheet
			if globalHub != nil {
				globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
			}
		}
	}
}

// adjustScriptTagsOnDeleteRow decrements row references in script tags for rows strictly above deleted row
// This function updates both same-sheet references and cross-sheet references, and updates scriptDeps
func (s *Sheet) adjustScriptTagsOnDeleteRow(deleteRow int) {
	sameSheetPattern := regexp.MustCompile(`\{\{([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	crossSheetPattern := regexp.MustCompile(`\{\{([^/\{\}]+)/([^/\{\}]+)/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	s.mu.Lock()
	// Adjust same-sheet references in this sheet
	type depUpd struct{ project, sheet, cellID, script, row, col string }
	pending := make([]depUpd, 0)
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if cell.Script == "" {
				continue
			}

			newScript := sameSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
				submatches := sameSheetPattern.FindStringSubmatch(match)
				if len(submatches) < 3 {
					return match
				}

				col1 := submatches[1]
				row1 := atoiSafe(submatches[2])

				// Single cell reference {{A2}}
				if submatches[3] == "" || submatches[4] == "" {
					if row1 == deleteRow {
						// Reference to deleted row becomes invalid - keep as is or mark
						return match
					}
					if row1 > deleteRow {
						row1--
					}
					return fmt.Sprintf("{{%s%d}}", col1, row1)
				}

				// Range reference {{A2:B3}}
				col2 := submatches[3]
				row2 := atoiSafe(submatches[4])

				// Handle deleted row in range
				if deleteRow >= row1 && deleteRow <= row2 {
					// Row is within range - shrink the range
					if row1 == row2 {
						// Single row range that got deleted - keep as invalid reference
						return match
					}
					if deleteRow == row1 {
						row1++
					} else if deleteRow == row2 {
						row2--
					}
					// If deleteRow is in the middle, just adjust the end
					if row2 > deleteRow {
						row2--
					}
				} else {
					// Adjust if above deleted row
					if row1 > deleteRow {
						row1--
					}
					if row2 > deleteRow {
						row2--
					}
				}

				return fmt.Sprintf("{{%s%d:%s%d}}", col1, row1, col2, row2)
			})

			if newScript != cell.Script {
				cell.Script = newScript
				s.Data[rowKey][colKey] = cell
				pending = append(pending, depUpd{s.ProjectName, s.Name, cell.CellID, newScript, rowKey, colKey})
			}
		}
	}
	s.mu.Unlock()
	for _, u := range pending {
		globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s)
	}
	// Send ROW_COL_UPDATED message to clients if any scripts were modified in this sheet
	if len(pending) > 0 && globalHub != nil {
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}
	// Adjust cross-sheet references in sheets that reference this sheet
	// Use scriptDeps to find which sheets have dependencies on this sheet
	sheet_Key := s.ProjectName + "/" + s.Name
	globalSheetManager.scriptDepsMu.RLock()
	scriptIdentifiers, hasRefs := globalSheetManager.scriptDeps[sheet_Key]
	globalSheetManager.scriptDepsMu.RUnlock()

	if !hasRefs {
		return // No cross-sheet references to this sheet
	}

	// Collect unique sheets that reference this sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	globalSheetManager.mu.RLock()
	for _, si := range scriptIdentifiers {
		key := sheetKey(si.ScriptProjectName, si.ScriptSheetName)
		if !seenSheets[key] {
			if sheet, ok := globalSheetManager.sheets[key]; ok && sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[key] = true
			}
		}
	}
	globalSheetManager.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if cell.Script == "" {
					continue
				}

				newScript := crossSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
					submatches := crossSheetPattern.FindStringSubmatch(match)
					if len(submatches) < 5 {
						return match
					}

					refProject := submatches[1]
					refSheet := submatches[2]

					// Only adjust if referencing the current sheet
					if refProject != s.ProjectName || refSheet != s.Name {
						return match
					}

					col1 := submatches[3]
					row1 := atoiSafe(submatches[4])

					// Single cell reference {{project/sheet/A2}}
					if submatches[5] == "" || submatches[6] == "" {
						if row1 == deleteRow {
							// Reference to deleted row becomes invalid - keep as is
							return match
						}
						if row1 > deleteRow {
							row1--
						}
						return fmt.Sprintf("{{%s/%s/%s%d}}", refProject, refSheet, col1, row1)
					}

					// Range reference {{project/sheet/A2:B3}}
					col2 := submatches[5]
					row2 := atoiSafe(submatches[6])

					// Handle deleted row in range
					if deleteRow >= row1 && deleteRow <= row2 {
						// Row is within range - shrink the range
						if row1 == row2 {
							// Single row range that got deleted - keep as invalid reference
							return match
						}
						if deleteRow == row1 {
							row1++
						} else if deleteRow == row2 {
							row2--
						}
						// If deleteRow is in the middle, just adjust the end
						if row2 > deleteRow {
							row2--
						}
					} else {
						// Adjust if above deleted row
						if row1 > deleteRow {
							row1--
						}
						if row2 > deleteRow {
							row2--
						}
					}

					return fmt.Sprintf("{{%s/%s/%s%d:%s%d}}", refProject, refSheet, col1, row1, col2, row2)
				})

				if newScript != cell.Script {
					cell.Script = newScript
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			type depUpd2 struct{ project, sheet, cellID, script, row, col string }
			updList := make([]depUpd2, 0)
			sheet.mu.RLock()
			for rKey, rowMap := range sheet.Data {
				for cKey, cell := range rowMap {
					if cell.Script != "" {
						updList = append(updList, depUpd2{sheet.ProjectName, sheet.Name, cell.CellID, cell.Script, rKey, cKey})
					}
				}
			}
			sheet.mu.RUnlock()
			for _, u := range updList {
				globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
			}
			globalSheetManager.SaveSheet(sheet)
			// Send ROW_COL_UPDATED m
			// essage to clients for this modified sheet
			if globalHub != nil {
				globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
			}
		}
	}
}

// adjustScriptTagsOnMoveRow adjusts row references in script tags for a row move from fromRow to destIndex
// This function updates both same-sheet references and cross-sheet references, and updates scriptDeps
func (s *Sheet) adjustScriptTagsOnMoveRow(fromRow, destIndex int) {
	sameSheetPattern := regexp.MustCompile(`\{\{([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	crossSheetPattern := regexp.MustCompile(`\{\{([^/\{\}]+)/([^/\{\}]+)/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	s.mu.Lock()
	// Adjust same-sheet references in this sheet
	type depUpd struct{ project, sheet, cellID, script, row, col string }
	pending := make([]depUpd, 0)
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if cell.Script == "" {
				continue
			}

			newScript := sameSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
				submatches := sameSheetPattern.FindStringSubmatch(match)
				if len(submatches) < 3 {
					return match
				}

				col1 := submatches[1]
				row1 := atoiSafe(submatches[2])

				// Single cell reference {{A2}}
				if submatches[3] == "" || submatches[4] == "" {
					if row1 == 0 {
						return match
					}

					if fromRow < destIndex {
						if row1 == fromRow {
							row1 = destIndex
						} else if row1 > fromRow && row1 <= destIndex {
							row1--
						}
					} else if fromRow > destIndex {
						if row1 == fromRow {
							row1 = destIndex
						} else if row1 >= destIndex && row1 < fromRow {
							row1++
						}
					}
					return fmt.Sprintf("{{%s%d}}", col1, row1)
				}

				// Range reference {{A2:B3}}
				col2 := submatches[3]
				row2 := atoiSafe(submatches[4])

				if row1 == 0 || row2 == 0 {
					return match
				}

				if fromRow < destIndex {
					if row1 == fromRow {
						row1 = destIndex
					} else if row1 > fromRow && row1 <= destIndex {
						row1--
					}
					if row2 == fromRow {
						row2 = destIndex
					} else if row2 > fromRow && row2 <= destIndex {
						row2--
					}
				} else if fromRow > destIndex {
					if row1 == fromRow {
						row1 = destIndex
					} else if row1 >= destIndex && row1 < fromRow {
						row1++
					}
					if row2 == fromRow {
						row2 = destIndex
					} else if row2 >= destIndex && row2 < fromRow {
						row2++
					}
				}

				return fmt.Sprintf("{{%s%d:%s%d}}", col1, row1, col2, row2)
			})

			if newScript != cell.Script {
				cell.Script = newScript
				s.Data[rowKey][colKey] = cell
				pending = append(pending, depUpd{s.ProjectName, s.Name, cell.CellID, newScript, rowKey, colKey})
			}
		}
	}
	s.mu.Unlock()
	for _, u := range pending {
		globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s) // persist the row move before clients fetch updated sheet
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s)
	}
	// Send ROW_COL_UPDATED message to clients if any scripts were modified in this sheet
	if len(pending) > 0 && globalHub != nil {
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}
	// Adjust cross-sheet references in sheets that reference this sheet
	// Use scriptDeps to find which sheets have dependencies on this sheet
	sheet_Key := s.ProjectName + "/" + s.Name
	globalSheetManager.scriptDepsMu.RLock()
	scriptIdentifiers, hasRefs := globalSheetManager.scriptDeps[sheet_Key]
	globalSheetManager.scriptDepsMu.RUnlock()

	if !hasRefs {
		return // No cross-sheet references to this sheet
	}

	// Collect unique sheets that reference this sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	globalSheetManager.mu.RLock()
	for _, si := range scriptIdentifiers {
		key := sheetKey(si.ScriptProjectName, si.ScriptSheetName)
		if !seenSheets[key] {
			if sheet, ok := globalSheetManager.sheets[key]; ok && sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[key] = true
			}
		}
	}
	globalSheetManager.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if cell.Script == "" {
					continue
				}

				newScript := crossSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
					submatches := crossSheetPattern.FindStringSubmatch(match)
					if len(submatches) < 5 {
						return match
					}

					refProject := submatches[1]
					refSheet := submatches[2]

					// Only adjust if referencing the current sheet
					if refProject != s.ProjectName || refSheet != s.Name {
						return match
					}

					col1 := submatches[3]
					row1 := atoiSafe(submatches[4])

					// Single cell reference {{project/sheet/A2}}
					if submatches[5] == "" || submatches[6] == "" {
						if row1 == 0 {
							return match
						}

						if fromRow < destIndex {
							if row1 == fromRow {
								row1 = destIndex
							} else if row1 > fromRow && row1 <= destIndex {
								row1--
							}
						} else if fromRow > destIndex {
							if row1 == fromRow {
								row1 = destIndex
							} else if row1 >= destIndex && row1 < fromRow {
								row1++
							}
						}
						return fmt.Sprintf("{{%s/%s/%s%d}}", refProject, refSheet, col1, row1)
					}

					// Range reference {{project/sheet/A2:B3}}
					col2 := submatches[5]
					row2 := atoiSafe(submatches[6])

					if row1 == 0 || row2 == 0 {
						return match
					}

					if fromRow < destIndex {
						if row1 == fromRow {
							row1 = destIndex
						} else if row1 > fromRow && row1 <= destIndex {
							row1--
						}
						if row2 == fromRow {
							row2 = destIndex
						} else if row2 > fromRow && row2 <= destIndex {
							row2--
						}
					} else if fromRow > destIndex {
						if row1 == fromRow {
							row1 = destIndex
						} else if row1 >= destIndex && row1 < fromRow {
							row1++
						}
						if row2 == fromRow {
							row2 = destIndex
						} else if row2 >= destIndex && row2 < fromRow {
							row2++
						}
					}

					return fmt.Sprintf("{{%s/%s/%s%d:%s%d}}", refProject, refSheet, col1, row1, col2, row2)
				})

				if newScript != cell.Script {
					cell.Script = newScript
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			type depUpd2 struct{ project, sheet, cellID, script, row, col string }
			updList := make([]depUpd2, 0)
			sheet.mu.RLock()
			for rKey, rowMap := range sheet.Data {
				for cKey, cell := range rowMap {
					if cell.Script != "" {
						updList = append(updList, depUpd2{sheet.ProjectName, sheet.Name, cell.CellID, cell.Script, rKey, cKey})
					}
				}
			}
			sheet.mu.RUnlock()
			for _, u := range updList {
				globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
			}
			globalSheetManager.SaveSheet(sheet) // persist the row move before clients fetch updated sheet
			// Send ROW_COL_UPDATED message to clients for this modified sheet
			if globalHub != nil {
				globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
			}
		}
	}
}

// adjustScriptTagsOnInsertCol increments column references in script tags for columns at or beyond insertIdx
// This function updates both same-sheet references and cross-sheet references, and updates scriptDeps
func (s *Sheet) adjustScriptTagsOnInsertCol(insertIdx int) {
	sameSheetPattern := regexp.MustCompile(`\{\{([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	crossSheetPattern := regexp.MustCompile(`\{\{([^/\{\}]+)/([^/\{\}]+)/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	s.mu.Lock()
	// Adjust same-sheet references in this sheet
	type depUpd struct{ project, sheet, cellID, script, row, col string }
	pending := make([]depUpd, 0)
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if cell.Script == "" {
				continue
			}

			newScript := sameSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
				submatches := sameSheetPattern.FindStringSubmatch(match)
				if len(submatches) < 3 {
					return match
				}

				col1 := submatches[1]
				row1 := submatches[2]
				col1Idx := colLabelToIndex(col1)

				// Single cell reference {{A2}}
				if submatches[3] == "" || submatches[4] == "" {
					if col1Idx >= insertIdx && col1Idx > 0 {
						col1Idx++
						col1 = indexToColLabel(col1Idx)
					}
					return fmt.Sprintf("{{%s%s}}", col1, row1)
				}

				// Range reference {{A2:B3}}
				col2 := submatches[3]
				row2 := submatches[4]
				col2Idx := colLabelToIndex(col2)

				if col1Idx >= insertIdx && col1Idx > 0 {
					col1Idx++
					col1 = indexToColLabel(col1Idx)
				}
				if col2Idx >= insertIdx && col2Idx > 0 {
					col2Idx++
					col2 = indexToColLabel(col2Idx)
				}

				return fmt.Sprintf("{{%s%s:%s%s}}", col1, row1, col2, row2)
			})

			if newScript != cell.Script {
				cell.Script = newScript
				s.Data[rowKey][colKey] = cell
				pending = append(pending, depUpd{s.ProjectName, s.Name, cell.CellID, newScript, rowKey, colKey})
			}
		}
	}
	s.mu.Unlock()
	for _, u := range pending {
		globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s) // persist the column insert before clients fetch updated sheet
	}
	// Send ROW_COL_UPDATED message to clients if any scripts were modified in this sheet
	if len(pending) > 0 && globalHub != nil {
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}
	// Adjust cross-sheet references in sheets that reference this sheet
	// Use scriptDeps to find which sheets have dependencies on this sheet
	sheet_Key := s.ProjectName + "/" + s.Name
	globalSheetManager.scriptDepsMu.RLock()
	scriptIdentifiers, hasRefs := globalSheetManager.scriptDeps[sheet_Key]
	globalSheetManager.scriptDepsMu.RUnlock()

	if !hasRefs {
		return // No cross-sheet references to this sheet
	}

	// Collect unique sheets that reference this sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	globalSheetManager.mu.RLock()
	for _, si := range scriptIdentifiers {
		key := sheetKey(si.ScriptProjectName, si.ScriptSheetName)
		if !seenSheets[key] {
			if sheet, ok := globalSheetManager.sheets[key]; ok && sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[key] = true
			}
		}
	}
	globalSheetManager.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if cell.Script == "" {
					continue
				}

				newScript := crossSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
					submatches := crossSheetPattern.FindStringSubmatch(match)
					if len(submatches) < 5 {
						return match
					}

					refProject := submatches[1]
					refSheet := submatches[2]

					// Only adjust if referencing the current sheet
					if refProject != s.ProjectName || refSheet != s.Name {
						return match
					}

					col1 := submatches[3]
					row1 := submatches[4]
					col1Idx := colLabelToIndex(col1)

					// Single cell reference {{project/sheet/A2}}
					if submatches[5] == "" || submatches[6] == "" {
						if col1Idx >= insertIdx && col1Idx > 0 {
							col1Idx++
							col1 = indexToColLabel(col1Idx)
						}
						return fmt.Sprintf("{{%s/%s/%s%s}}", refProject, refSheet, col1, row1)
					}

					// Range reference {{project/sheet/A2:B3}}
					col2 := submatches[5]
					row2 := submatches[6]
					col2Idx := colLabelToIndex(col2)

					if col1Idx >= insertIdx && col1Idx > 0 {
						col1Idx++
						col1 = indexToColLabel(col1Idx)
					}
					if col2Idx >= insertIdx && col2Idx > 0 {
						col2Idx++
						col2 = indexToColLabel(col2Idx)
					}

					return fmt.Sprintf("{{%s/%s/%s%s:%s%s}}", refProject, refSheet, col1, row1, col2, row2)
				})

				if newScript != cell.Script {
					cell.Script = newScript
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			type depUpd2 struct{ project, sheet, cellID, script, row, col string }
			updList := make([]depUpd2, 0)
			sheet.mu.RLock()
			for rKey, rowMap := range sheet.Data {
				for cKey, cell := range rowMap {
					if cell.Script != "" {
						updList = append(updList, depUpd2{sheet.ProjectName, sheet.Name, cell.CellID, cell.Script, rKey, cKey})
					}
				}
			}
			sheet.mu.RUnlock()
			for _, u := range updList {
				globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
			}
			globalSheetManager.SaveSheet(sheet) // persist the column insert before clients fetch updated sheet
			// Send ROW_COL_UPDATED message to clients for this modified sheet
			if globalHub != nil {
				globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
			}
		}
	}
}

// adjustScriptTagsOnDeleteCol decrements column references in script tags for columns strictly right of deleted column
// This function updates both same-sheet references and cross-sheet references, and updates scriptDeps
func (s *Sheet) adjustScriptTagsOnDeleteCol(deleteIdx int) {
	sameSheetPattern := regexp.MustCompile(`\{\{([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	crossSheetPattern := regexp.MustCompile(`\{\{([^/\{\}]+)/([^/\{\}]+)/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	s.mu.Lock()
	// Adjust same-sheet references in this sheet
	type depUpd struct{ project, sheet, cellID, script, row, col string }
	pending := make([]depUpd, 0)
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if cell.Script == "" {
				continue
			}

			newScript := sameSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
				submatches := sameSheetPattern.FindStringSubmatch(match)
				if len(submatches) < 3 {
					return match
				}

				col1 := submatches[1]
				row1 := submatches[2]
				col1Idx := colLabelToIndex(col1)

				// Single cell reference {{A2}}
				if submatches[3] == "" || submatches[4] == "" {
					if col1Idx == deleteIdx {
						// Reference to deleted column becomes invalid - keep as is
						return match
					}
					if col1Idx > deleteIdx {
						col1Idx--
						col1 = indexToColLabel(col1Idx)
					}
					return fmt.Sprintf("{{%s%s}}", col1, row1)
				}

				// Range reference {{A2:B3}}
				col2 := submatches[3]
				row2 := submatches[4]
				col2Idx := colLabelToIndex(col2)

				// Handle deleted column in range
				if deleteIdx >= col1Idx && deleteIdx <= col2Idx {
					// Column is within range - shrink the range
					if col1Idx == col2Idx {
						// Single column range that got deleted - keep as invalid reference
						return match
					}
					if deleteIdx == col1Idx {
						col1Idx++
						col1 = indexToColLabel(col1Idx)
					} else if deleteIdx == col2Idx {
						col2Idx--
						col2 = indexToColLabel(col2Idx)
					}
					// If deleteIdx is in the middle, just adjust the end
					if col2Idx > deleteIdx {
						col2Idx--
						col2 = indexToColLabel(col2Idx)
					}
				} else {
					// Adjust if to the right of deleted column
					if col1Idx > deleteIdx {
						col1Idx--
						col1 = indexToColLabel(col1Idx)
					}
					if col2Idx > deleteIdx {
						col2Idx--
						col2 = indexToColLabel(col2Idx)
					}
				}

				return fmt.Sprintf("{{%s%s:%s%s}}", col1, row1, col2, row2)
			})

			if newScript != cell.Script {
				cell.Script = newScript
				s.Data[rowKey][colKey] = cell
				pending = append(pending, depUpd{s.ProjectName, s.Name, cell.CellID, newScript, rowKey, colKey})
			}
		}
	}
	s.mu.Unlock()
	for _, u := range pending {
		globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s) // persist the column delete before clients fetch updated sheet
	}
	// Send ROW_COL_UPDATED message to clients if any scripts were modified in this sheet
	if len(pending) > 0 && globalHub != nil {
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}
	// Adjust cross-sheet references in sheets that reference this sheet
	// Use scriptDeps to find which sheets have dependencies on this sheet
	sheet_Key := s.ProjectName + "/" + s.Name
	globalSheetManager.scriptDepsMu.RLock()
	scriptIdentifiers, hasRefs := globalSheetManager.scriptDeps[sheet_Key]
	globalSheetManager.scriptDepsMu.RUnlock()

	if !hasRefs {
		return // No cross-sheet references to this sheet
	}

	// Collect unique sheets that reference this sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	globalSheetManager.mu.RLock()
	for _, si := range scriptIdentifiers {
		key := sheetKey(si.ScriptProjectName, si.ScriptSheetName)
		if !seenSheets[key] {
			if sheet, ok := globalSheetManager.sheets[key]; ok && sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[key] = true
			}
		}
	}
	globalSheetManager.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if cell.Script == "" {
					continue
				}

				newScript := crossSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
					submatches := crossSheetPattern.FindStringSubmatch(match)
					if len(submatches) < 5 {
						return match
					}

					refProject := submatches[1]
					refSheet := submatches[2]

					// Only adjust if referencing the current sheet
					if refProject != s.ProjectName || refSheet != s.Name {
						return match
					}

					col1 := submatches[3]
					row1 := submatches[4]
					col1Idx := colLabelToIndex(col1)

					// Single cell reference {{project/sheet/A2}}
					if submatches[5] == "" || submatches[6] == "" {
						if col1Idx == deleteIdx {
							// Reference to deleted column becomes invalid - keep as is
							return match
						}
						if col1Idx > deleteIdx {
							col1Idx--
							col1 = indexToColLabel(col1Idx)
						}
						return fmt.Sprintf("{{%s/%s/%s%s}}", refProject, refSheet, col1, row1)
					}

					// Range reference {{project/sheet/A2:B3}}
					col2 := submatches[5]
					row2 := submatches[6]
					col2Idx := colLabelToIndex(col2)

					// Handle deleted column in range
					if deleteIdx >= col1Idx && deleteIdx <= col2Idx {
						// Column is within range - shrink the range
						if col1Idx == col2Idx {
							// Single column range that got deleted - keep as invalid reference
							return match
						}
						if deleteIdx == col1Idx {
							col1Idx++
							col1 = indexToColLabel(col1Idx)
						} else if deleteIdx == col2Idx {
							col2Idx--
							col2 = indexToColLabel(col2Idx)
						}
						// If deleteIdx is in the middle, just adjust the end
						if col2Idx > deleteIdx {
							col2Idx--
							col2 = indexToColLabel(col2Idx)
						}
					} else {
						// Adjust if to the right of deleted column
						if col1Idx > deleteIdx {
							col1Idx--
							col1 = indexToColLabel(col1Idx)
						}
						if col2Idx > deleteIdx {
							col2Idx--
							col2 = indexToColLabel(col2Idx)
						}
					}

					return fmt.Sprintf("{{%s/%s/%s%s:%s%s}}", refProject, refSheet, col1, row1, col2, row2)
				})

				if newScript != cell.Script {
					cell.Script = newScript
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			type depUpd2 struct{ project, sheet, cellID, script, row, col string }
			updList := make([]depUpd2, 0)
			sheet.mu.RLock()
			for rKey, rowMap := range sheet.Data {
				for cKey, cell := range rowMap {
					if cell.Script != "" {
						updList = append(updList, depUpd2{sheet.ProjectName, sheet.Name, cell.CellID, cell.Script, rKey, cKey})
					}
				}
			}
			sheet.mu.RUnlock()
			for _, u := range updList {
				globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
			}
			globalSheetManager.SaveSheet(sheet) // persist the column delete before clients fetch updated sheet
			// Send ROW_COL_UPDATED message to clients for this modified sheet
			if globalHub != nil {
				globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
			}
		}
	}
}

// adjustScriptTagsOnMoveCol adjusts column references in script tags for a column move from fromIdx to destIdx
// This function updates both same-sheet references and cross-sheet references, and updates scriptDeps
func (s *Sheet) adjustScriptTagsOnMoveCol(fromIdx, destIdx int) {
	sameSheetPattern := regexp.MustCompile(`\{\{([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	crossSheetPattern := regexp.MustCompile(`\{\{([^/\{\}]+)/([^/\{\}]+)/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?\}\}`)
	s.mu.Lock()
	// Adjust same-sheet references in this sheet
	type depUpd struct{ project, sheet, cellID, script, row, col string }
	pending := make([]depUpd, 0)
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if cell.Script == "" {
				continue
			}

			newScript := sameSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
				submatches := sameSheetPattern.FindStringSubmatch(match)
				if len(submatches) < 3 {
					return match
				}

				col1 := submatches[1]
				row1 := submatches[2]
				col1Idx := colLabelToIndex(col1)

				// Single cell reference {{A2}}
				if submatches[3] == "" || submatches[4] == "" {
					if col1Idx == 0 {
						return match
					}

					oldIdx := col1Idx
					if fromIdx < destIdx {
						if col1Idx == fromIdx {
							col1Idx = destIdx
						} else if col1Idx > fromIdx && col1Idx <= destIdx {
							col1Idx--
						}
					} else if fromIdx > destIdx {
						if col1Idx == fromIdx {
							col1Idx = destIdx
						} else if col1Idx >= destIdx && col1Idx < fromIdx {
							col1Idx++
						}
					}

					if col1Idx != oldIdx {
						col1 = indexToColLabel(col1Idx)
					}
					return fmt.Sprintf("{{%s%s}}", col1, row1)
				}

				// Range reference {{A2:B3}}
				col2 := submatches[3]
				row2 := submatches[4]
				col2Idx := colLabelToIndex(col2)

				if col1Idx == 0 || col2Idx == 0 {
					return match
				}

				oldIdx1 := col1Idx
				oldIdx2 := col2Idx

				if fromIdx < destIdx {
					if col1Idx == fromIdx {
						col1Idx = destIdx
					} else if col1Idx > fromIdx && col1Idx <= destIdx {
						col1Idx--
					}
					if col2Idx == fromIdx {
						col2Idx = destIdx
					} else if col2Idx > fromIdx && col2Idx <= destIdx {
						col2Idx--
					}
				} else if fromIdx > destIdx {
					if col1Idx == fromIdx {
						col1Idx = destIdx
					} else if col1Idx >= destIdx && col1Idx < fromIdx {
						col1Idx++
					}
					if col2Idx == fromIdx {
						col2Idx = destIdx
					} else if col2Idx >= destIdx && col2Idx < fromIdx {
						col2Idx++
					}
				}

				if col1Idx != oldIdx1 {
					col1 = indexToColLabel(col1Idx)
				}
				if col2Idx != oldIdx2 {
					col2 = indexToColLabel(col2Idx)
				}

				return fmt.Sprintf("{{%s%s:%s%s}}", col1, row1, col2, row2)
			})

			if newScript != cell.Script {
				cell.Script = newScript
				s.Data[rowKey][colKey] = cell
				pending = append(pending, depUpd{s.ProjectName, s.Name, cell.CellID, newScript, rowKey, colKey})
			}
		}
	}
	s.mu.Unlock()
	for _, u := range pending {
		globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
	}
	if len(pending) > 0 {
		globalSheetManager.SaveSheet(s) // persist the column move before clients fetch updated sheet
	}
	// Send ROW_COL_UPDATED message to clients if any scripts were modified in this sheet
	if len(pending) > 0 && globalHub != nil {
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}
	// Adjust cross-sheet references in sheets that reference this sheet
	// Use scriptDeps to find which sheets have dependencies on this sheet
	sheet_Key := s.ProjectName + "/" + s.Name
	globalSheetManager.scriptDepsMu.RLock()
	scriptIdentifiers, hasRefs := globalSheetManager.scriptDeps[sheet_Key]
	globalSheetManager.scriptDepsMu.RUnlock()

	if !hasRefs {
		return // No cross-sheet references to this sheet
	}

	// Collect unique sheets that reference this sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	globalSheetManager.mu.RLock()
	for _, si := range scriptIdentifiers {
		key := sheetKey(si.ScriptProjectName, si.ScriptSheetName)
		if !seenSheets[key] {
			if sheet, ok := globalSheetManager.sheets[key]; ok && sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[key] = true
			}
		}
	}
	globalSheetManager.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if cell.Script == "" {
					continue
				}

				newScript := crossSheetPattern.ReplaceAllStringFunc(cell.Script, func(match string) string {
					submatches := crossSheetPattern.FindStringSubmatch(match)
					if len(submatches) < 5 {
						return match
					}

					refProject := submatches[1]
					refSheet := submatches[2]

					// Only adjust if referencing the current sheet
					if refProject != s.ProjectName || refSheet != s.Name {
						return match
					}

					col1 := submatches[3]
					row1 := submatches[4]
					col1Idx := colLabelToIndex(col1)

					// Single cell reference {{project/sheet/A2}}
					if submatches[5] == "" || submatches[6] == "" {
						if col1Idx == 0 {
							return match
						}

						oldIdx := col1Idx
						if fromIdx < destIdx {
							if col1Idx == fromIdx {
								col1Idx = destIdx
							} else if col1Idx > fromIdx && col1Idx <= destIdx {
								col1Idx--
							}
						} else if fromIdx > destIdx {
							if col1Idx == fromIdx {
								col1Idx = destIdx
							} else if col1Idx >= destIdx && col1Idx < fromIdx {
								col1Idx++
							}
						}

						if col1Idx != oldIdx {
							col1 = indexToColLabel(col1Idx)
						}
						return fmt.Sprintf("{{%s/%s/%s%s}}", refProject, refSheet, col1, row1)
					}

					// Range reference {{project/sheet/A2:B3}}
					col2 := submatches[5]
					row2 := submatches[6]
					col2Idx := colLabelToIndex(col2)

					if col1Idx == 0 || col2Idx == 0 {
						return match
					}

					oldIdx1 := col1Idx
					oldIdx2 := col2Idx

					if fromIdx < destIdx {
						if col1Idx == fromIdx {
							col1Idx = destIdx
						} else if col1Idx > fromIdx && col1Idx <= destIdx {
							col1Idx--
						}
						if col2Idx == fromIdx {
							col2Idx = destIdx
						} else if col2Idx > fromIdx && col2Idx <= destIdx {
							col2Idx--
						}
					} else if fromIdx > destIdx {
						if col1Idx == fromIdx {
							col1Idx = destIdx
						} else if col1Idx >= destIdx && col1Idx < fromIdx {
							col1Idx++
						}
						if col2Idx == fromIdx {
							col2Idx = destIdx
						} else if col2Idx >= destIdx && col2Idx < fromIdx {
							col2Idx++
						}
					}

					if col1Idx != oldIdx1 {
						col1 = indexToColLabel(col1Idx)
					}
					if col2Idx != oldIdx2 {
						col2 = indexToColLabel(col2Idx)
					}

					return fmt.Sprintf("{{%s/%s/%s%s:%s%s}}", refProject, refSheet, col1, row1, col2, row2)
				})

				if newScript != cell.Script {
					cell.Script = newScript
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			type depUpd2 struct{ project, sheet, cellID, script, row, col string }
			updList := make([]depUpd2, 0)
			sheet.mu.RLock()
			for rKey, rowMap := range sheet.Data {
				for cKey, cell := range rowMap {
					if cell.Script != "" {
						updList = append(updList, depUpd2{sheet.ProjectName, sheet.Name, cell.CellID, cell.Script, rKey, cKey})
					}
				}
			}
			sheet.mu.RUnlock()
			for _, u := range updList {
				globalSheetManager.UpdateScriptDependencies(u.project, u.sheet, u.cellID, u.script, u.row, u.col)
			}
			globalSheetManager.SaveSheet(sheet) // persist the column move before clients fetch updated sheet
			// Send ROW_COL_UPDATED message to clients for this modified sheet
			if globalHub != nil {
				globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
			}
		}
	}
}

// (Removed) MoveColumnToIndex: undo now uses MOVE_COL with computed target column.

func (sm *SheetManager) ListSheets() []*Sheet {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	list := make([]*Sheet, 0, len(sm.sheets))
	for _, sheet := range sm.sheets {
		list = append(list, sheet)
	}
	return list
}

/*
func (sm *SheetManager) RenameSheet(id, newName, user string) bool {
	// Phase 1: locate sheet and remember old map key under manager lock
	sm.mu.Lock()
	var sheet *Sheet
	var oldKey string
	for k, s := range sm.sheets {
		if s != nil && s.Name == id {
			sheet = s
			oldKey = k
			break
		}
	}
	sm.mu.Unlock()

	if sheet == nil {
		return false
	}

	// Phase 2: rename file + update sheet fields under sheet lock
	sheet.mu.Lock()
	oldName := sheet.Name
	var dir string
	if sheet.ProjectName != "" {
		dir = filepath.Join(dataDir, sheet.ProjectName)
	} else {
		dir = dataDir
	}
	oldPath := filepath.Join(dir, oldName+".json")
	newPath := filepath.Join(dir, newName+".json")
	if err := os.Rename(oldPath, newPath); err != nil {
		log.Printf("Error renaming sheet file from %s to %s: %v", oldPath, newPath, err)
		sheet.mu.Unlock()
		return false
	}
	sheet.Name = newName
	sheet.mu.Unlock()

	// Phase 3: update manager map keys under short manager lock
	sm.mu.Lock()
	delete(sm.sheets, oldKey)
	sm.sheets[sheetKey(sheet.ProjectName, newName)] = sheet
	sm.mu.Unlock()

	// Project-level audit
	globalProjectAuditManager.Append(sheet.ProjectName, user, "RENAME_SHEET", "Renamed sheet from '"+oldName+"' to '"+newName+"'")

	// Update dependencies (no manager lock required)
	sm.RenameSheetInDependencies(sheet.ProjectName, oldName, newName)
	sm.RenameSheetInOptionsRangeDependencies(sheet.ProjectName, oldName, newName)

	// Persist with new key without holding manager lock
	sm.saveSheetLocked(sheet)
	return true
}
*/
// RenameSheetBy renames a sheet identified by name and project.
// This renames the actual file on disk and updates all dependency references.
func (sm *SheetManager) RenameSheetBy(name, project, newName, user string) bool {
	// Phase 1: locate sheet and remember old key under manager lock
	sm.mu.Lock()
	var sheet *Sheet
	var oldKey string
	if s, ok := sm.sheets[sheetKey(project, name)]; ok {
		sheet = s
		oldKey = sheetKey(project, name)
	} else {
		for k, s := range sm.sheets {
			if s != nil && s.Name == name && s.ProjectName == project {
				sheet = s
				oldKey = k
				break
			}
		}
	}
	sm.mu.Unlock()

	if sheet == nil {
		return false
	}

	// Phase 2: rename file + update sheet fields under sheet lock
	sheet.mu.Lock()
	oldName := sheet.Name
	var dir string
	if sheet.ProjectName != "" {
		dir = filepath.Join(dataDir, sheet.ProjectName)
	} else {
		dir = dataDir
	}
	oldPath := filepath.Join(dir, oldName+".json")
	newPath := filepath.Join(dir, newName+".json")
	if err := os.Rename(oldPath, newPath); err != nil {
		log.Printf("Error renaming sheet file from %s to %s: %v", oldPath, newPath, err)
		sheet.mu.Unlock()
		return false
	}
	sheet.Name = newName
	sheet.mu.Unlock()

	// Phase 3: update the sheets map key under short manager lock
	sm.mu.Lock()
	delete(sm.sheets, oldKey)
	sm.sheets[sheetKey(project, newName)] = sheet
	sm.mu.Unlock()

	// Project-level audit
	globalProjectAuditManager.Append(project, user, "RENAME_SHEET", "Renamed sheet from '"+oldName+"' to '"+newName+"'")

	// Update dependencies (no manager lock required)
	sm.RenameSheetInDependencies(project, oldName, newName)
	sm.RenameSheetInOptionsRangeDependencies(project, oldName, newName)

	// Persist with new key without holding manager lock
	sm.saveSheetLocked(sheet)
	return true
}

/*
func (sm *SheetManager) DeleteSheet(id string) bool {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	// Find entry by id
	var sheet *Sheet
	for _, s := range sm.sheets {
		if s != nil && s.Name == id {
			sheet = s
			break
		}
	}
	if sheet == nil {
		return false
	}

	// Delete using computed composite key
	delete(sm.sheets, sheetKey(sheet.ProjectName, id))

	// Remove the sheet file
	var filePath string
	if sheet.ProjectName != "" {
		filePath = filepath.Join(dataDir, sheet.ProjectName, id+".json")
	} else {
		filePath = getSheetFilePath(id)
	}
	if err := os.Remove(filePath); err != nil {
		log.Printf("Error deleting sheet file %s: %v", filePath, err)
	}

	return true
}

*/
// DeleteSheetBy deletes a sheet with id and project from memory and disk.
func (sm *SheetManager) DeleteSheetBy(name, project string) bool {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	var sheet *Sheet
	if s, ok := sm.sheets[sheetKey(project, name)]; ok {
		sheet = s
	} else {
		for _, s := range sm.sheets {
			if s != nil && s.Name == name && s.ProjectName == project {
				sheet = s
				break
			}
		}
	}
	if sheet == nil {
		return false
	}

	delete(sm.sheets, sheetKey(project, name))

	// Remove the sheet file
	var filePath string
	if sheet.ProjectName != "" {
		filePath = filepath.Join(dataDir, sheet.ProjectName, name+".json")
	} else {
		filePath = getSheetFilePath(name)
	}
	if err := os.Remove(filePath); err != nil {
		log.Printf("Error deleting sheet file %s: %v", filePath, err)
	}

	return true
}

// DeleteSheetsByProject removes all sheets in a given project from memory and disk.
func (sm *SheetManager) DeleteSheetsByProject(projectName string) {
	sm.mu.Lock()
	// Collect names to delete to avoid mutating map during iteration
	names := make([]string, 0)
	for _, s := range sm.sheets {
		if s.ProjectName == projectName {
			names = append(names, s.Name)
		}
	}
	sm.mu.Unlock()
	for _, name := range names {
		sm.DeleteSheetBy(name, projectName)
	}
}

func (sm *SheetManager) SaveSheet(sheet *Sheet) {
	// Schedule a debounced save instead of writing immediately
	if sheet == nil {
		return
	}
	// Build key from sheet fields safely
	sheet.mu.RLock()
	proj := sheet.ProjectName
	id := sheet.Name
	sheet.mu.RUnlock()

	key := sheetKey(proj, id)
	now := time.Now()
	sm.mu.Lock()
	if ps, ok := sm.pending[key]; ok {
		ps.lastModified = now
		// keep existing sheet pointer; it always refers to same instance
	} else {
		sm.pending[key] = &pendingSave{sheet: sheet, lastModified: now}
	}
	sm.mu.Unlock()
}

func (sm *SheetManager) Save() {
	sm.mu.RLock()
	defer sm.mu.RUnlock()
	// Save all sheets
	for _, sheet := range sm.sheets {
		sm.saveSheetLocked(sheet)
	}
}

func (sm *SheetManager) Load() {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	// Check if DATA directory exists
	if _, err := os.Stat(dataDir); os.IsNotExist(err) {
		log.Println("DATA directory does not exist, starting fresh")
		return
	}

	loadedCount := 0

	// Load sheets from root (backward compatibility)
	/*
		rootFiles, err := filepath.Glob(filepath.Join(dataDir, "*.json"))
		if err == nil {
			for _, filePath := range rootFiles {
				base := filepath.Base(filePath)
				// Skip non-sheet files like chat.json, projects.json, users.json
				if base == "chat.json" || base == "projects.json" || base == "users.json" || base == "project_audit.log" {
					continue
				}
				file, err := os.Open(filePath)
				if err != nil {
					log.Printf("Error opening sheet file %s: %v", filePath, err)
					continue
				}
				var sheet Sheet
				if err := json.NewDecoder(file).Decode(&sheet); err != nil {
					log.Printf("Error decoding sheet file %s: %v", filePath, err)
					file.Close()
					continue
				}
				file.Close()
				sm.sheets[sheetKey(sheet.ProjectName, sheet.ID)] = &sheet
				loadedCount++
			}
		}
	*/
	// Load sheets from project subdirectories (recursive)
	entries, err := os.ReadDir(dataDir)
	if err != nil {
		log.Printf("Error reading DATA directory: %v", err)
	} else {
		for _, entry := range entries {
			if !entry.IsDir() {
				continue
			}
			topProject := entry.Name()
			baseDir := filepath.Join(dataDir, topProject)
			// Walk recursively and read any *.json sheet file
			filepath.WalkDir(baseDir, func(path string, d os.DirEntry, err error) error {
				if err != nil {
					return nil
				}
				if d.IsDir() {
					return nil
				}
				if filepath.Ext(path) != ".json" {
					return nil
				}
				// Skip non-sheet meta files
				base := filepath.Base(path)
				if base == "chat.json" || base == "projects.json" || base == "users.json" || base == "project_audit.log" {
					return nil
				}
				file, err := os.Open(path)
				if err != nil {
					log.Printf("Error opening sheet file %s: %v", path, err)
					return nil
				}
				var sheet Sheet
				if err := json.NewDecoder(file).Decode(&sheet); err != nil {
					log.Printf("Error decoding sheet file %s: %v", path, err)
					file.Close()
					return nil
				}
				file.Close()
				//  infer relative project path from DATA dir
				//if sheet.ProjectName == "" {
				rel, relErr := filepath.Rel(dataDir, filepath.Dir(path))
				if relErr == nil {
					sheet.ProjectName = rel
				} else {
					sheet.ProjectName = topProject
				}
				//}
				//  use file name without extension
				//if sheet.Name == "" {
				sheet.Name = strings.TrimSuffix(d.Name(), filepath.Ext(d.Name()))
				//}
				sm.sheets[sheetKey(sheet.ProjectName, sheet.Name)] = &sheet
				loadedCount++
				return nil
			})
		}
	}

	log.Printf("Loaded %d sheets from disk", loadedCount)

	// Rebuild script dependency map from loaded sheets
	sm.rebuildScriptDependencies()
	// Rebuild OptionsRange dependency map from loaded sheets
	sm.rebuildOptionsRangeDependencies()
}

// rebuildScriptDependencies rebuilds the script dependency map from all loaded sheets
// This should be called after loading sheets from disk on startup
func (sm *SheetManager) rebuildScriptDependencies() {
	sm.scriptDepsMu.Lock()
	defer sm.scriptDepsMu.Unlock()

	// Clear existing dependencies
	sm.scriptDeps = make(map[string][]ScriptIdentifier)

	// Iterate through all sheets and extract dependencies from scripts
	for _, sheet := range sm.sheets {
		if sheet == nil {
			continue
		}

		sheet.mu.RLock()
		projectName := sheet.ProjectName
		sheetName := sheet.Name

		// Iterate with keys to capture row and column labels
		for rowLabel, rowMap := range sheet.Data {
			for colLabel, cell := range rowMap {
				if strings.TrimSpace(cell.Script) == "" {
					continue
				}

				// Extract dependencies for this script
				deps := ExtractScriptDependencies(cell.Script, projectName, sheetName)
				if len(deps) == 0 {
					// No explicit references found; add self cell as dependency
					deps = append(deps, DependencyInfo{
						Project: projectName,
						Sheet:   sheetName,
						Range:   colLabel + rowLabel,
					})
				}
				// Add to dependency map
				for _, dep := range deps {
					sheetKey := dep.Project + "/" + dep.Sheet
					scriptIdent := ScriptIdentifier{
						ScriptProjectName: projectName,
						ScriptSheetName:   sheetName,
						ScriptCellID:      cell.CellID,
						ReferencedRange:   dep.Range,
					}
					sm.scriptDeps[sheetKey] = append(sm.scriptDeps[sheetKey], scriptIdent)
				}
			}
		}
		sheet.mu.RUnlock()
	}

	log.Printf("Rebuilt script dependency map with %d referenced sheets", len(sm.scriptDeps))
}

// rebuildOptionsRangeDependencies rebuilds the OptionsRange dependency map from all loaded sheets
// This should be called after loading sheets from disk on startup
func (sm *SheetManager) rebuildOptionsRangeDependencies() {
	sm.OptionsRangeDepsMu.Lock()
	defer sm.OptionsRangeDepsMu.Unlock()

	// Clear existing dependencies
	sm.OptionsRangeDeps = make(map[string][]CellIdentifier)

	// Iterate through all sheets and extract OptionsRange dependencies
	for _, sheet := range sm.sheets {
		if sheet == nil {
			continue
		}

		sheet.mu.RLock()
		projectName := sheet.ProjectName
		sheetName := sheet.Name

		for rowLabel, rowMap := range sheet.Data {
			for colLabel, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				// Parse the OptionsRange to determine which sheet it depends on
				deps := parseOptionsRangeDependency(cell.OptionsRange, projectName, sheetName)
				for _, dep := range deps {
					depKey := dep.Project + "/" + dep.Sheet
					sm.OptionsRangeDeps[depKey] = append(sm.OptionsRangeDeps[depKey], CellIdentifier{
						ProjectName: projectName,
						sheetName:   sheetName,
						row:         rowLabel,
						col:         colLabel,
					})
				}
			}
		}
		sheet.mu.RUnlock()
	}

	log.Printf("Rebuilt OptionsRange dependency map with %d referenced sheets", len(sm.OptionsRangeDeps))
}

// parseOptionsRangeDependency parses an OptionsRange string and returns dependency info.
// OptionsRange can be "A1:A10" (same sheet) or "projectname/sheetid/A1:A10" (cross-sheet).
func parseOptionsRangeDependency(optionsRange, currentProject, currentSheet string) []DependencyInfo {
	optionsRange = strings.TrimSpace(optionsRange)
	if optionsRange == "" {
		return nil
	}

	var deps []DependencyInfo

	slashParts := strings.Split(optionsRange, "/")
	if len(slashParts) >= 3 {
		// Cross-sheet reference: project/.../sheetid/A1:A10
		// The range is the last segment, sheet name is second-to-last,
		// and the project path (may contain slashes for subfolders) is everything before.
		n := len(slashParts)
		deps = append(deps, DependencyInfo{
			Project: strings.Join(slashParts[:n-2], "/"),
			Sheet:   slashParts[n-2],
			Range:   slashParts[n-1],
		})
	} else {
		// Same-sheet reference: A1:A10
		deps = append(deps, DependencyInfo{
			Project: currentProject,
			Sheet:   currentSheet,
			Range:   optionsRange,
		})
	}

	return deps
}

// UpdateOptionsRangeDependencies updates the OptionsRange dependency map for a cell.
// Should be called whenever a cell's OptionsRange is set or changed.
func (sm *SheetManager) UpdateOptionsRangeDependencies(cellProjectName, cellSheetName, cellRow, cellCol, optionsRange string) {
	sm.OptionsRangeDepsMu.Lock()
	defer sm.OptionsRangeDepsMu.Unlock()

	// Remove old dependencies for this cell (check all sheet keys)
	for depKey, cells := range sm.OptionsRangeDeps {
		filtered := make([]CellIdentifier, 0, len(cells))
		for _, c := range cells {
			if c.ProjectName != cellProjectName || c.sheetName != cellSheetName || c.row != cellRow || c.col != cellCol {
				filtered = append(filtered, c)
			}
		}
		if len(filtered) > 0 {
			sm.OptionsRangeDeps[depKey] = filtered
		} else {
			delete(sm.OptionsRangeDeps, depKey)
		}
	}

	// If optionsRange is empty, we're done (dependencies removed)
	if strings.TrimSpace(optionsRange) == "" {
		return
	}

	// Add new dependencies
	deps := parseOptionsRangeDependency(optionsRange, cellProjectName, cellSheetName)
	for _, dep := range deps {
		depKey := dep.Project + "/" + dep.Sheet
		sm.OptionsRangeDeps[depKey] = append(sm.OptionsRangeDeps[depKey], CellIdentifier{
			ProjectName: cellProjectName,
			sheetName:   cellSheetName,
			row:         cellRow,
			col:         cellCol,
		})
	}
}

// RenameProjectInOptionsRangeDependencies updates OptionsRange dependency references when a project is renamed.
// It also updates the OptionsRange field in all cells that reference the old project name.
func (sm *SheetManager) RenameProjectInOptionsRangeDependencies(oldProject, newProject string) {
	sm.OptionsRangeDepsMu.Lock()
	defer sm.OptionsRangeDepsMu.Unlock()

	// Create new map with updated keys
	newDeps := make(map[string][]CellIdentifier)

	for depKey, cells := range sm.OptionsRangeDeps {
		newDepKey := depKey
		parts := strings.Split(depKey, "/")
		if len(parts) >= 2 && parts[0] == oldProject {
			parts[0] = newProject
			newDepKey = strings.Join(parts, "/")
		}

		// Update cell identifiers (including those in subfolders)
		newCells := make([]CellIdentifier, 0, len(cells))
		for _, c := range cells {
			if c.ProjectName == oldProject {
				c.ProjectName = newProject
			} else if strings.HasPrefix(c.ProjectName, oldProject+"/") {
				c.ProjectName = newProject + c.ProjectName[len(oldProject):]
			}
			newCells = append(newCells, c)
		}

		newDeps[newDepKey] = newCells
	}

	sm.OptionsRangeDeps = newDeps

	// Update OptionsRange field in all cells that reference the old project name
	sm.mu.RLock()
	sheetsToUpdate := make([]*Sheet, 0, len(sm.sheets))
	for _, sheet := range sm.sheets {
		sheetsToUpdate = append(sheetsToUpdate, sheet)
	}
	sm.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) != "" {
					oldPattern := oldProject + "/"
					if strings.HasPrefix(cell.OptionsRange, oldPattern) {
						cell.OptionsRange = newProject + "/" + cell.OptionsRange[len(oldPattern):]
						sheet.Data[rowKey][colKey] = cell
						modified = true
					}
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sm.SaveSheet(sheet)
		}
	}
}

// RenameSheetInOptionsRangeDependencies updates OptionsRange dependency references when a sheet is renamed within a project.
// It also updates the OptionsRange field in all cells that reference the old sheet name.
func (sm *SheetManager) RenameSheetInOptionsRangeDependencies(projectName, oldSheetName, newSheetName string) {
	sm.OptionsRangeDepsMu.Lock()
	defer sm.OptionsRangeDepsMu.Unlock()

	// Create new map with updated keys
	newDeps := make(map[string][]CellIdentifier)

	for depKey, cells := range sm.OptionsRangeDeps {
		newDepKey := depKey
		parts := strings.Split(depKey, "/")
		// depKey format is "project/sheet"
		if len(parts) >= 2 && parts[0] == projectName && parts[1] == oldSheetName {
			parts[1] = newSheetName
			newDepKey = strings.Join(parts, "/")
		}

		// Update cell identifiers that belong to the renamed sheet
		newCells := make([]CellIdentifier, 0, len(cells))
		for _, c := range cells {
			if c.ProjectName == projectName && c.sheetName == oldSheetName {
				c.sheetName = newSheetName
			}
			newCells = append(newCells, c)
		}

		newDeps[newDepKey] = newCells
	}

	sm.OptionsRangeDeps = newDeps

	// Update OptionsRange field in all cells that reference the old sheet name
	// Pattern: "projectname/oldSheetName/A1:A10" -> "projectname/newSheetName/A1:A10"
	sm.mu.RLock()
	sheetsToUpdate := make([]*Sheet, 0, len(sm.sheets))
	for _, sheet := range sm.sheets {
		sheetsToUpdate = append(sheetsToUpdate, sheet)
	}
	sm.mu.RUnlock()

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) != "" {
					oldPattern := projectName + "/" + oldSheetName + "/"
					if strings.HasPrefix(cell.OptionsRange, oldPattern) {
						cell.OptionsRange = projectName + "/" + newSheetName + "/" + cell.OptionsRange[len(oldPattern):]
						sheet.Data[rowKey][colKey] = cell
						modified = true
					}
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sm.SaveSheet(sheet)
		}
	}
}

// adjustOptionsRangeOnInsertRow adjusts OptionsRange references in all cells when a row is inserted.
// This handles same-sheet references inline and cross-sheet references via OptionsRangeDeps.
func (s *Sheet) adjustOptionsRangeOnInsertRow(insertRow int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	s.mu.Lock()
	modified := false
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) == "" {
				continue
			}
			newRange := adjustRangeRefOnInsertRow(cell.OptionsRange, insertRow, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
			if newRange != cell.OptionsRange {
				cell.OptionsRange = newRange
				// Re-extract options from the new range
				s.Data[rowKey][colKey] = cell
				modified = true
			}
		}
	}
	s.mu.Unlock()

	if modified {
		// Re-extract options for modified cells and update deps
		s.refreshOptionsFromRanges()
		globalSheetManager.SaveSheet(s)
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}

	// Adjust cross-sheet OptionsRange references
	s.adjustCrossSheetOptionsRangeOnInsertRow(insertRow)
}

// adjustOptionsRangeOnDeleteRow adjusts OptionsRange references in all cells when a row is deleted.
func (s *Sheet) adjustOptionsRangeOnDeleteRow(deleteRow int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	s.mu.Lock()
	modified := false
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) == "" {
				continue
			}
			newRange := adjustRangeRefOnDeleteRow(cell.OptionsRange, deleteRow, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
			if newRange != cell.OptionsRange {
				cell.OptionsRange = newRange
				s.Data[rowKey][colKey] = cell
				modified = true
			}
		}
	}
	s.mu.Unlock()

	if modified {
		s.refreshOptionsFromRanges()
		globalSheetManager.SaveSheet(s)
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}

	s.adjustCrossSheetOptionsRangeOnDeleteRow(deleteRow)
}

// adjustOptionsRangeOnMoveRow adjusts OptionsRange references in all cells when a row is moved.
func (s *Sheet) adjustOptionsRangeOnMoveRow(fromRow, destIndex int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	s.mu.Lock()
	modified := false
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) == "" {
				continue
			}
			newRange := adjustRangeRefOnMoveRow(cell.OptionsRange, fromRow, destIndex, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
			if newRange != cell.OptionsRange {
				cell.OptionsRange = newRange
				s.Data[rowKey][colKey] = cell
				modified = true
			}
		}
	}
	s.mu.Unlock()

	if modified {
		s.refreshOptionsFromRanges()
		globalSheetManager.SaveSheet(s)
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}

	s.adjustCrossSheetOptionsRangeOnMoveRow(fromRow, destIndex)
}

// adjustOptionsRangeOnInsertCol adjusts OptionsRange references in all cells when a column is inserted.
func (s *Sheet) adjustOptionsRangeOnInsertCol(insertIdx int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	s.mu.Lock()
	modified := false
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) == "" {
				continue
			}
			newRange := adjustRangeRefOnInsertCol(cell.OptionsRange, insertIdx, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
			if newRange != cell.OptionsRange {
				cell.OptionsRange = newRange
				s.Data[rowKey][colKey] = cell
				modified = true
			}
		}
	}
	s.mu.Unlock()

	if modified {
		s.refreshOptionsFromRanges()
		globalSheetManager.SaveSheet(s)
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}

	s.adjustCrossSheetOptionsRangeOnInsertCol(insertIdx)
}

// adjustOptionsRangeOnDeleteCol adjusts OptionsRange references in all cells when a column is deleted.
func (s *Sheet) adjustOptionsRangeOnDeleteCol(deleteIdx int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	s.mu.Lock()
	modified := false
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) == "" {
				continue
			}
			newRange := adjustRangeRefOnDeleteCol(cell.OptionsRange, deleteIdx, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
			if newRange != cell.OptionsRange {
				cell.OptionsRange = newRange
				s.Data[rowKey][colKey] = cell
				modified = true
			}
		}
	}
	s.mu.Unlock()

	if modified {
		s.refreshOptionsFromRanges()
		globalSheetManager.SaveSheet(s)
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}

	s.adjustCrossSheetOptionsRangeOnDeleteCol(deleteIdx)
}

// adjustOptionsRangeOnMoveCol adjusts OptionsRange references in all cells when a column is moved.
func (s *Sheet) adjustOptionsRangeOnMoveCol(fromIdx, destIdx int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	s.mu.Lock()
	modified := false
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) == "" {
				continue
			}
			newRange := adjustRangeRefOnMoveCol(cell.OptionsRange, fromIdx, destIdx, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
			if newRange != cell.OptionsRange {
				cell.OptionsRange = newRange
				s.Data[rowKey][colKey] = cell
				modified = true
			}
		}
	}
	s.mu.Unlock()

	if modified {
		s.refreshOptionsFromRanges()
		globalSheetManager.SaveSheet(s)
		globalSheetManager.QueueRowColUpdate(s.ProjectName, s.Name)
	}

	s.adjustCrossSheetOptionsRangeOnMoveCol(fromIdx, destIdx)
}

// refreshOptionsFromRanges re-extracts options from OptionsRange for all cells that have one set.
// Should be called after adjusting OptionsRange references.
func (s *Sheet) refreshOptionsFromRanges() {
	s.mu.Lock()
	// Collect cells that need options refresh
	type cellRef struct {
		row, col     string
		optionsRange string
	}
	var toRefresh []cellRef
	for rowKey, rowMap := range s.Data {
		for colKey, cell := range rowMap {
			if strings.TrimSpace(cell.OptionsRange) != "" {
				toRefresh = append(toRefresh, cellRef{rowKey, colKey, cell.OptionsRange})
			}
		}
	}
	s.mu.Unlock()

	for _, ref := range toRefresh {
		extractedOptions := s.extractOptionsFromRange(ref.optionsRange)
		s.mu.Lock()
		if len(extractedOptions) > 0 {
			cell := s.Data[ref.row][ref.col]
			cell.Options = extractedOptions
			s.Data[ref.row][ref.col] = cell
		}
		s.mu.Unlock()
	}

	// Update OptionsRange dependencies for all modified cells
	for _, ref := range toRefresh {
		globalSheetManager.UpdateOptionsRangeDependencies(s.ProjectName, s.Name, ref.row, ref.col, ref.optionsRange)
	}
}

// Helper functions for adjusting range references

func adjustRangeRefOnInsertRow(rangeStr string, insertRow int, refProject, refSheet, curProject, curSheet string, samePattern, crossPattern *regexp.Regexp) string {
	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) == 3 {
		// Cross-sheet: project/sheet/A1:B10
		rProject := slashParts[0]
		rSheet := slashParts[1]
		rRange := slashParts[2]
		if rProject != curProject || rSheet != curSheet {
			return rangeStr // Not referencing the sheet being modified
		}
		newRange := adjustSameSheetRangeOnInsertRow(rRange, insertRow, samePattern)
		return rProject + "/" + rSheet + "/" + newRange
	}
	// Same-sheet
	return adjustSameSheetRangeOnInsertRow(rangeStr, insertRow, samePattern)
}

func adjustSameSheetRangeOnInsertRow(rangeStr string, insertRow int, pattern *regexp.Regexp) string {
	m := pattern.FindStringSubmatch(rangeStr)
	if m == nil {
		return rangeStr
	}
	col1 := m[1]
	row1 := atoiSafe(m[2])
	col2 := m[3]
	row2 := atoiSafe(m[4])

	if row1 >= insertRow && row1 > 0 {
		row1++
	}
	if row2 >= insertRow && row2 > 0 {
		row2++
	}
	return fmt.Sprintf("%s%d:%s%d", col1, row1, col2, row2)
}

func adjustRangeRefOnDeleteRow(rangeStr string, deleteRow int, refProject, refSheet, curProject, curSheet string, samePattern, crossPattern *regexp.Regexp) string {
	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) == 3 {
		rProject := slashParts[0]
		rSheet := slashParts[1]
		rRange := slashParts[2]
		if rProject != curProject || rSheet != curSheet {
			return rangeStr
		}
		newRange := adjustSameSheetRangeOnDeleteRow(rRange, deleteRow, samePattern)
		return rProject + "/" + rSheet + "/" + newRange
	}
	return adjustSameSheetRangeOnDeleteRow(rangeStr, deleteRow, samePattern)
}

func adjustSameSheetRangeOnDeleteRow(rangeStr string, deleteRow int, pattern *regexp.Regexp) string {
	m := pattern.FindStringSubmatch(rangeStr)
	if m == nil {
		return rangeStr
	}
	col1 := m[1]
	row1 := atoiSafe(m[2])
	col2 := m[3]
	row2 := atoiSafe(m[4])

	if deleteRow >= row1 && deleteRow <= row2 {
		if row1 == row2 {
			return rangeStr // Single row range deleted - keep as is
		}
		row2--
	} else {
		if row1 > deleteRow {
			row1--
		}
		if row2 > deleteRow {
			row2--
		}
	}
	return fmt.Sprintf("%s%d:%s%d", col1, row1, col2, row2)
}

func adjustRangeRefOnMoveRow(rangeStr string, fromRow, destIndex int, refProject, refSheet, curProject, curSheet string, samePattern, crossPattern *regexp.Regexp) string {
	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) == 3 {
		rProject := slashParts[0]
		rSheet := slashParts[1]
		rRange := slashParts[2]
		if rProject != curProject || rSheet != curSheet {
			return rangeStr
		}
		newRange := adjustSameSheetRangeOnMoveRow(rRange, fromRow, destIndex, samePattern)
		return rProject + "/" + rSheet + "/" + newRange
	}
	return adjustSameSheetRangeOnMoveRow(rangeStr, fromRow, destIndex, samePattern)
}

func adjustSameSheetRangeOnMoveRow(rangeStr string, fromRow, destIndex int, pattern *regexp.Regexp) string {
	m := pattern.FindStringSubmatch(rangeStr)
	if m == nil {
		return rangeStr
	}
	col1 := m[1]
	row1 := atoiSafe(m[2])
	col2 := m[3]
	row2 := atoiSafe(m[4])

	adjustRow := func(r int) int {
		if fromRow < destIndex {
			if r == fromRow {
				return destIndex
			} else if r > fromRow && r <= destIndex {
				return r - 1
			}
		} else if fromRow > destIndex {
			if r == fromRow {
				return destIndex
			} else if r >= destIndex && r < fromRow {
				return r + 1
			}
		}
		return r
	}

	row1 = adjustRow(row1)
	row2 = adjustRow(row2)
	return fmt.Sprintf("%s%d:%s%d", col1, row1, col2, row2)
}

func adjustRangeRefOnInsertCol(rangeStr string, insertIdx int, refProject, refSheet, curProject, curSheet string, samePattern, crossPattern *regexp.Regexp) string {
	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) == 3 {
		rProject := slashParts[0]
		rSheet := slashParts[1]
		rRange := slashParts[2]
		if rProject != curProject || rSheet != curSheet {
			return rangeStr
		}
		newRange := adjustSameSheetRangeOnInsertCol(rRange, insertIdx, samePattern)
		return rProject + "/" + rSheet + "/" + newRange
	}
	return adjustSameSheetRangeOnInsertCol(rangeStr, insertIdx, samePattern)
}

func adjustSameSheetRangeOnInsertCol(rangeStr string, insertIdx int, pattern *regexp.Regexp) string {
	m := pattern.FindStringSubmatch(rangeStr)
	if m == nil {
		return rangeStr
	}
	col1 := m[1]
	row1 := m[2]
	col2 := m[3]
	row2 := m[4]

	col1Idx := colLabelToIndex(col1)
	col2Idx := colLabelToIndex(col2)

	if col1Idx >= insertIdx && col1Idx > 0 {
		col1Idx++
		col1 = indexToColLabel(col1Idx)
	}
	if col2Idx >= insertIdx && col2Idx > 0 {
		col2Idx++
		col2 = indexToColLabel(col2Idx)
	}
	return fmt.Sprintf("%s%s:%s%s", col1, row1, col2, row2)
}

func adjustRangeRefOnDeleteCol(rangeStr string, deleteIdx int, refProject, refSheet, curProject, curSheet string, samePattern, crossPattern *regexp.Regexp) string {
	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) == 3 {
		rProject := slashParts[0]
		rSheet := slashParts[1]
		rRange := slashParts[2]
		if rProject != curProject || rSheet != curSheet {
			return rangeStr
		}
		newRange := adjustSameSheetRangeOnDeleteCol(rRange, deleteIdx, samePattern)
		return rProject + "/" + rSheet + "/" + newRange
	}
	return adjustSameSheetRangeOnDeleteCol(rangeStr, deleteIdx, samePattern)
}

func adjustSameSheetRangeOnDeleteCol(rangeStr string, deleteIdx int, pattern *regexp.Regexp) string {
	m := pattern.FindStringSubmatch(rangeStr)
	if m == nil {
		return rangeStr
	}
	col1 := m[1]
	row1 := m[2]
	col2 := m[3]
	row2 := m[4]

	col1Idx := colLabelToIndex(col1)
	col2Idx := colLabelToIndex(col2)

	if deleteIdx >= col1Idx && deleteIdx <= col2Idx {
		if col1Idx == col2Idx {
			return rangeStr // Single column range deleted - keep as is
		}
		col2Idx--
		col2 = indexToColLabel(col2Idx)
	} else {
		if col1Idx > deleteIdx {
			col1Idx--
			col1 = indexToColLabel(col1Idx)
		}
		if col2Idx > deleteIdx {
			col2Idx--
			col2 = indexToColLabel(col2Idx)
		}
	}
	return fmt.Sprintf("%s%s:%s%s", col1, row1, col2, row2)
}

func adjustRangeRefOnMoveCol(rangeStr string, fromIdx, destIdx int, refProject, refSheet, curProject, curSheet string, samePattern, crossPattern *regexp.Regexp) string {
	slashParts := strings.Split(rangeStr, "/")
	if len(slashParts) == 3 {
		rProject := slashParts[0]
		rSheet := slashParts[1]
		rRange := slashParts[2]
		if rProject != curProject || rSheet != curSheet {
			return rangeStr
		}
		newRange := adjustSameSheetRangeOnMoveCol(rRange, fromIdx, destIdx, samePattern)
		return rProject + "/" + rSheet + "/" + newRange
	}
	return adjustSameSheetRangeOnMoveCol(rangeStr, fromIdx, destIdx, samePattern)
}

func adjustSameSheetRangeOnMoveCol(rangeStr string, fromIdx, destIdx int, pattern *regexp.Regexp) string {
	m := pattern.FindStringSubmatch(rangeStr)
	if m == nil {
		return rangeStr
	}
	col1 := m[1]
	row1 := m[2]
	col2 := m[3]
	row2 := m[4]

	col1Idx := colLabelToIndex(col1)
	col2Idx := colLabelToIndex(col2)

	adjustCol := func(idx int) int {
		if fromIdx < destIdx {
			if idx == fromIdx {
				return destIdx
			} else if idx > fromIdx && idx <= destIdx {
				return idx - 1
			}
		} else if fromIdx > destIdx {
			if idx == fromIdx {
				return destIdx
			} else if idx >= destIdx && idx < fromIdx {
				return idx + 1
			}
		}
		return idx
	}

	newCol1Idx := adjustCol(col1Idx)
	newCol2Idx := adjustCol(col2Idx)

	if newCol1Idx != col1Idx {
		col1 = indexToColLabel(newCol1Idx)
	}
	if newCol2Idx != col2Idx {
		col2 = indexToColLabel(newCol2Idx)
	}
	return fmt.Sprintf("%s%s:%s%s", col1, row1, col2, row2)
}

// Cross-sheet OptionsRange adjustment helpers

func (s *Sheet) adjustCrossSheetOptionsRangeOnInsertRow(insertRow int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	sheetKey := s.ProjectName + "/" + s.Name
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()
	if !hasDeps {
		return
	}

	// Group by sheet
	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if dep.ProjectName == s.ProjectName && dep.sheetName == s.Name {
			continue // Same sheet - already handled
		}
		if !seenSheets[sk] {
			sheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[sk] = true
			}
		}
	}

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				newRange := adjustRangeRefOnInsertRow(cell.OptionsRange, insertRow, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
				if newRange != cell.OptionsRange {
					cell.OptionsRange = newRange
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sheet.refreshOptionsFromRanges()
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}

func (s *Sheet) adjustCrossSheetOptionsRangeOnDeleteRow(deleteRow int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	sheetKey := s.ProjectName + "/" + s.Name
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()
	if !hasDeps {
		return
	}

	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if dep.ProjectName == s.ProjectName && dep.sheetName == s.Name {
			continue
		}
		if !seenSheets[sk] {
			sheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[sk] = true
			}
		}
	}

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				newRange := adjustRangeRefOnDeleteRow(cell.OptionsRange, deleteRow, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
				if newRange != cell.OptionsRange {
					cell.OptionsRange = newRange
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sheet.refreshOptionsFromRanges()
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}

func (s *Sheet) adjustCrossSheetOptionsRangeOnMoveRow(fromRow, destIndex int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	sheetKey := s.ProjectName + "/" + s.Name
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()
	if !hasDeps {
		return
	}

	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if dep.ProjectName == s.ProjectName && dep.sheetName == s.Name {
			continue
		}
		if !seenSheets[sk] {
			sheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[sk] = true
			}
		}
	}

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				newRange := adjustRangeRefOnMoveRow(cell.OptionsRange, fromRow, destIndex, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
				if newRange != cell.OptionsRange {
					cell.OptionsRange = newRange
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sheet.refreshOptionsFromRanges()
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}

func (s *Sheet) adjustCrossSheetOptionsRangeOnInsertCol(insertIdx int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	sheetKey := s.ProjectName + "/" + s.Name
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()
	if !hasDeps {
		return
	}

	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if dep.ProjectName == s.ProjectName && dep.sheetName == s.Name {
			continue
		}
		if !seenSheets[sk] {
			sheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[sk] = true
			}
		}
	}

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				newRange := adjustRangeRefOnInsertCol(cell.OptionsRange, insertIdx, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
				if newRange != cell.OptionsRange {
					cell.OptionsRange = newRange
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sheet.refreshOptionsFromRanges()
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}

func (s *Sheet) adjustCrossSheetOptionsRangeOnDeleteCol(deleteIdx int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	sheetKey := s.ProjectName + "/" + s.Name
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()
	if !hasDeps {
		return
	}

	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if dep.ProjectName == s.ProjectName && dep.sheetName == s.Name {
			continue
		}
		if !seenSheets[sk] {
			sheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[sk] = true
			}
		}
	}

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				newRange := adjustRangeRefOnDeleteCol(cell.OptionsRange, deleteIdx, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
				if newRange != cell.OptionsRange {
					cell.OptionsRange = newRange
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sheet.refreshOptionsFromRanges()
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}

func (s *Sheet) adjustCrossSheetOptionsRangeOnMoveCol(fromIdx, destIdx int) {
	sameSheetRangePattern := regexp.MustCompile(`^([A-Z]+)(\d+):([A-Z]+)(\d+)$`)
	crossSheetRangePattern := regexp.MustCompile(`^([^/]+)/([^/]+)/([A-Z]+)(\d+):([A-Z]+)(\d+)$`)

	sheetKey := s.ProjectName + "/" + s.Name
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()
	if !hasDeps {
		return
	}

	seenSheets := make(map[string]bool)
	sheetsToUpdate := make([]*Sheet, 0)
	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if dep.ProjectName == s.ProjectName && dep.sheetName == s.Name {
			continue
		}
		if !seenSheets[sk] {
			sheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if sheet != nil {
				sheetsToUpdate = append(sheetsToUpdate, sheet)
				seenSheets[sk] = true
			}
		}
	}

	for _, sheet := range sheetsToUpdate {
		sheet.mu.Lock()
		modified := false
		for rowKey, rowMap := range sheet.Data {
			for colKey, cell := range rowMap {
				if strings.TrimSpace(cell.OptionsRange) == "" {
					continue
				}
				newRange := adjustRangeRefOnMoveCol(cell.OptionsRange, fromIdx, destIdx, s.ProjectName, s.Name, s.ProjectName, s.Name, sameSheetRangePattern, crossSheetRangePattern)
				if newRange != cell.OptionsRange {
					cell.OptionsRange = newRange
					sheet.Data[rowKey][colKey] = cell
					modified = true
				}
			}
		}
		sheet.mu.Unlock()

		if modified {
			sheet.refreshOptionsFromRanges()
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}

// CopyPasteProject copies all sheets from sourcePath to destPath, rewriting cross-sheet
// references from the source prefix to the destination prefix.
// sourcePath can be a top-level project or a subfolder (e.g. "proj/sub1").
// destPath is the full destination path (e.g. "proj2" or "proj/sub2").
// The newOwner will be set as owner for all copied sheets (and ensured in editors).
// Returns error if destPath is inside sourcePath (pasting into itself).
func (sm *SheetManager) CopyPasteProject(sourcePath, destPath, newOwner string) error {
	if sourcePath == "" || destPath == "" {
		return fmt.Errorf("source and destination paths required")
	}

	// Prevent pasting inside itself: destPath must not equal sourcePath or be a child of it
	if destPath == sourcePath || strings.HasPrefix(destPath, sourcePath+"/") {
		return fmt.Errorf("cannot paste a folder inside itself")
	}

	// Ensure top-level destination directory
	if err := os.MkdirAll(filepath.Join(dataDir, destPath), 0755); err != nil {
		return fmt.Errorf("failed to create dest directory: %w", err)
	}

	// rewriteRef replaces every occurrence of the sourcePath prefix in a cross-sheet
	// reference string (Script or OptionsRange) with destPath.
	// Cross-sheet refs are written as "sourcePath/..." so a simple prefix replacement is safe.
	rewriteRef := func(ref string) string {
		oldPrefix := sourcePath + "/"
		newPrefix := destPath + "/"
		// Also handle exact match (e.g. "sourcePath/sheetId/A1")
		ref = strings.ReplaceAll(ref, oldPrefix, newPrefix)
		return ref
	}

	sm.mu.Lock()
	defer sm.mu.Unlock()

	for _, s := range sm.sheets {
		if s == nil {
			continue
		}
		// Include sheets at the source level AND all subfolder sheets
		if s.ProjectName != sourcePath && !strings.HasPrefix(s.ProjectName, sourcePath+"/") {
			continue
		}

		// Compute the ProjectName for the clone: replace the leading sourcePath with destPath
		var cloneProjectName string
		if s.ProjectName == sourcePath {
			cloneProjectName = destPath
		} else {
			cloneProjectName = destPath + s.ProjectName[len(sourcePath):]
		}

		// Ensure the subfolder directory exists in the new tree
		if err := os.MkdirAll(filepath.Join(dataDir, cloneProjectName), 0755); err != nil {
			return fmt.Errorf("failed to create subfolder %s: %w", cloneProjectName, err)
		}

		// Build permissions for the clone
		perms := s.Permissions
		hasOwner := false
		for _, e := range perms.Editors {
			if e == newOwner {
				hasOwner = true
				break
			}
		}
		if !hasOwner && newOwner != "" {
			perms.Editors = append(perms.Editors, newOwner)
		}

		clone := &Sheet{
			Name:        s.Name,
			Owner:       newOwner,
			ProjectName: cloneProjectName,
			Data:        make(map[string]map[string]Cell),
			ColWidths:   make(map[string]int),
			RowHeights:  make(map[string]int),
			Permissions: perms,
			AuditLog:    append([]AuditEntry{}, s.AuditLog...),
		}

		// Deep copy cell data, rewriting any cross-sheet references from source to dest
		s.mu.RLock()
		for r, cols := range s.Data {
			clone.Data[r] = make(map[string]Cell, len(cols))
			for c, cell := range cols {
				// Rewrite Script: replace {{sourcePath/...}} with {{destPath/...}}
				if strings.TrimSpace(cell.Script) != "" {
					cell.Script = rewriteRef(cell.Script)
				}
				// Rewrite OptionsRange: replace sourcePath/... with destPath/...
				if strings.TrimSpace(cell.OptionsRange) != "" {
					cell.OptionsRange = rewriteRef(cell.OptionsRange)
				}
				clone.Data[r][c] = cell
			}
		}
		for k, v := range s.ColWidths {
			clone.ColWidths[k] = v
		}
		for k, v := range s.RowHeights {
			clone.RowHeights[k] = v
		}
		s.mu.RUnlock()

		// Register in memory and persist to disk
		sm.sheets[sheetKey(cloneProjectName, clone.Name)] = clone
		sm.saveSheetLocked(clone)
	}
	return nil
}

// updateOptionsForDependentCells updates options for combo box/multiple selection cells
// that depend on the modified cell's sheet via OptionsRange
func updateOptionsForDependentCells(projectName, sheetName, row, col string) {
	sheetKey := projectName + "/" + sheetName

	// Get cells that depend on this sheet for their options
	globalSheetManager.OptionsRangeDepsMu.RLock()
	deps, hasDeps := globalSheetManager.OptionsRangeDeps[sheetKey]
	globalSheetManager.OptionsRangeDepsMu.RUnlock()

	if !hasDeps {
		return
	}

	// Group dependent cells by sheet to minimize sheet lookups
	type sheetCells struct {
		sheet *Sheet
		cells []CellIdentifier
	}

	sheetMap := make(map[string]*sheetCells)

	for _, dep := range deps {
		sk := dep.ProjectName + "::" + dep.sheetName
		if sheetMap[sk] == nil {
			depSheet := globalSheetManager.GetSheetBy(dep.sheetName, dep.ProjectName)
			if depSheet == nil {
				continue
			}
			sheetMap[sk] = &sheetCells{
				sheet: depSheet,
				cells: []CellIdentifier{},
			}
		}
		sheetMap[sk].cells = append(sheetMap[sk].cells, dep)
	}

	// Update each dependent sheet
	for _, sc := range sheetMap {
		sheet := sc.sheet
		modified := false

		for _, dep := range sc.cells {
			sheet.mu.Lock()
			if sheet.Data[dep.row] == nil || sheet.Data[dep.row][dep.col].OptionsRange == "" {
				sheet.mu.Unlock()
				continue
			}

			cell := sheet.Data[dep.row][dep.col]

			// Skip if cell is not a combo box or multiple selection
			if cell.CellType != ComboBoxCell && cell.CellType != MultipleSelectionCell {
				sheet.mu.Unlock()
				continue
			}

			optionsRange := cell.OptionsRange
			sheet.mu.Unlock()

			// Extract new options from the range
			extractedOptions := sheet.extractOptionsFromRange(optionsRange)

			if len(extractedOptions) > 0 {
				sheet.mu.Lock()
				cell = sheet.Data[dep.row][dep.col]
				oldOptions := cell.Options
				cell.Options = extractedOptions

				// Update value based on OptionsSelected
				if cell.CellType == ComboBoxCell {
					// For combo box, set value from the selected option
					if len(cell.OptionsSelected) > 0 && cell.OptionsSelected[0] < len(cell.Options) {
						cell.Value = cell.Options[cell.OptionsSelected[0]]
					} else {
						// If OptionsSelected is invalid or empty, clear the value
						cell.Value = ""
						cell.OptionsSelected = nil
					}
				} else if cell.CellType == MultipleSelectionCell {
					// For multiple selection, concatenate selected values with semicolon
					var selectedValues []string
					validIndices := []int{}
					for _, idx := range cell.OptionsSelected {
						if idx < len(cell.Options) {
							selectedValues = append(selectedValues, cell.Options[idx])
							validIndices = append(validIndices, idx)
						}
					}
					cell.Value = strings.Join(selectedValues, "; ")
					cell.OptionsSelected = validIndices
				}

				sheet.Data[dep.row][dep.col] = cell
				sheet.mu.Unlock()

				modified = true

				// Check if options actually changed
				optionsChanged := len(oldOptions) != len(extractedOptions)
				if !optionsChanged {
					for i := range oldOptions {
						if oldOptions[i] != extractedOptions[i] {
							optionsChanged = true
							break
						}
					}
				}

				// If options changed, we may need to re-execute dependent scripts
				if optionsChanged {
					// Queue this cell for script execution if it has dependent scripts
					globalSheetManager.CellsModifiedByScriptQueueMu.Lock()
					globalSheetManager.CellsModifiedByScriptQueue = append(globalSheetManager.CellsModifiedByScriptQueue, CellIdentifier{dep.ProjectName, dep.sheetName, dep.row, dep.col})
					globalSheetManager.CellsModifiedByScriptQueueMu.Unlock()
				}
			}
		}

		if modified {
			globalSheetManager.SaveSheet(sheet)
			globalSheetManager.QueueRowColUpdate(sheet.ProjectName, sheet.Name)
		}
	}
}
